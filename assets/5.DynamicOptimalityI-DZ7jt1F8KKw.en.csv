text,start,stop
"The following content is
provided under a Creative",00:00:00.090,00:00:02.490
Commons license.,00:00:02.490,00:00:04.059
"Your support will help
MIT OpenCourseWare",00:00:04.059,00:00:06.360
"continue to offer high quality
educational resources for free.",00:00:06.360,00:00:10.720
"To make a donation or
view additional materials",00:00:10.720,00:00:13.320
"from hundreds of MIT courses,
visit MIT OpenCourseWare",00:00:13.320,00:00:17.280
at ocw.mit.edu,00:00:17.280,00:00:21.110
"PROFESSOR: All right today we
begin a topic dear to my heart.",00:00:21.110,00:00:24.240
"It's a problem that's
still pretty open,",00:00:24.240,00:00:26.430
but I've worked on a lot.,00:00:26.430,00:00:27.840
Dynamic optimality.,00:00:27.840,00:00:29.400
"Central question here is, is
there one binary search tree",00:00:29.400,00:00:32.850
"that's at least as good as
all other binary search trees?",00:00:32.850,00:00:35.310
"Is there one binary search
tree to rule them all?",00:00:35.310,00:00:38.580
"It's kind of a
fundamental question.",00:00:38.580,00:00:40.230
Goes back to the '80s.,00:00:40.230,00:00:42.980
"In particular splay trees, which
you have probably seen before.",00:00:42.980,00:00:46.580
We'll review them briefly here.,00:00:46.580,00:00:49.080
"And there's a lot of
technology built up,",00:00:49.080,00:00:50.820
"which we'll talk about this
lecture and next lecture,",00:00:50.820,00:00:53.670
"about how to tackle
this problem.",00:00:53.670,00:00:56.050
"It's still active
area of research.",00:00:56.050,00:00:59.310
"So before I get to-- well
the central question here is,",00:00:59.310,00:01:06.580
"is there one best
binary search tree?",00:01:06.580,00:01:13.500
"It's a natural question because
we use binary search trees",00:01:16.634,00:01:19.050
all the time.,00:01:19.050,00:01:19.591
"Already in this class,
probably every lecture,",00:01:19.591,00:01:21.510
"we've used a binary
search tree for something.",00:01:21.510,00:01:24.190
"And we all know how to do order
log in balanced binary search",00:01:24.190,00:01:30.880
trees.,00:01:30.880,00:01:31.380
"And the question becomes,
is this the best you can do?",00:01:35.760,00:01:38.940
"To make this more formal
of a problem, well, yeah.",00:01:49.590,00:01:59.260
"I want to define binary search
tree as a model of computation.",00:01:59.260,00:02:05.340
"OK we've talked about
pointer machine model.",00:02:05.340,00:02:07.640
"Binary search tree model is
a more restricted version",00:02:07.640,00:02:10.930
of pointer machine.,00:02:10.930,00:02:11.980
"So it's less than
pointer machine.",00:02:11.980,00:02:14.920
"Just so it's clear what
the name of this game is,",00:02:18.270,00:02:21.940
"we require the data to be
stored in a binary search",00:02:21.940,00:02:30.820
tree as it's keys.,00:02:30.820,00:02:34.525
"And then we allow
basic operations.",00:02:40.120,00:02:42.550
"Let me make sure I
get the right list.",00:02:46.610,00:02:51.910
"You can follow
pointers, and we're",00:03:01.950,00:03:03.930
"going to assume our BST
has left triad pointers,",00:03:03.930,00:03:07.140
"right triad pointers,
and parent pointers.",00:03:07.140,00:03:09.270
"You can do each of
these in constant time.",00:03:09.270,00:03:11.370
"And then the interesting one,
interesting thing you can do,",00:03:11.370,00:03:14.850
is rotate a node and its parent.,00:03:14.850,00:03:18.210
"So sure you've seen
rotations before.",00:03:23.550,00:03:26.960
"If this is my node
x, and I do rotate",00:03:34.160,00:03:36.410
"x, it's going to be my
definition of rotation,",00:03:36.410,00:03:43.070
x moves to the root.,00:03:43.070,00:03:44.840
"It's in this case because x
is to the right of it's parent",00:03:44.840,00:03:47.770
"it remains now to the
right of it's, what",00:03:47.770,00:03:51.870
now becomes it's child.,00:03:51.870,00:03:52.940
"These sub-trees come
along for the ride.",00:03:56.100,00:03:58.250
"This preserves the binary
search tree property.",00:03:58.250,00:04:01.280
"And you could get
back by rotating y.",00:04:01.280,00:04:03.564
"OK by this definition
of rotate we",00:04:06.230,00:04:08.547
"don't need to
distinguish between left",00:04:08.547,00:04:10.130
and right rotations.,00:04:10.130,00:04:12.230
"We always name the child and
it's parent is well defined.",00:04:12.230,00:04:15.490
That's who we rotate with.,00:04:15.490,00:04:17.190
So it's just flipping this edge.,00:04:17.190,00:04:20.010
"So these are the operations
you can do, and in this model",00:04:20.010,00:04:23.120
"really the only thing
you can do is a search.",00:04:23.120,00:04:25.190
"Suppose I want to
search for a key.",00:04:25.190,00:04:27.650
"The model is to do a search I
start at the root of the tree,",00:04:27.650,00:04:38.300
of the binary search tree.,00:04:38.300,00:04:39.620
I can do these walks.,00:04:39.620,00:04:40.670
I could do rotations.,00:04:40.670,00:04:42.500
And I must visit--,00:04:42.500,00:04:44.930
"if I'm going to search for x,
must visit the node with key",00:04:44.930,00:04:55.970
equal to x.,00:04:55.970,00:04:58.160
"And we're going to assume
throughout these lectures",00:04:58.160,00:05:00.290
"that searches are
always successful.",00:05:00.290,00:05:01.850
"You're only searching for
keys that are in the tree.",00:05:01.850,00:05:04.557
"Doesn't make that
much of a difference",00:05:04.557,00:05:06.140
"if you're searching for keys
that are not in the tree.",00:05:06.140,00:05:08.000
"Think of it as searching for the
predecessor or the successor.",00:05:08.000,00:05:10.880
Not a big deal.,00:05:10.880,00:05:12.146
"And so for
simplicity, we're just",00:05:12.146,00:05:13.520
"going to assume
successful searches.",00:05:13.520,00:05:16.820
"We're also going to assume
no insertions and deletions",00:05:16.820,00:05:19.790
"in this model, because they just
make problem a little messier.",00:05:19.790,00:05:24.020
"Some papers have considered
insertions and deletions,",00:05:24.020,00:05:26.690
"and to the large extent
things just work.",00:05:26.690,00:05:28.670
"So, we're going to
focus on searches.",00:05:28.670,00:05:31.150
"Searches is interesting
enough for this problem.",00:05:31.150,00:05:34.740
Suppose I have n items.,00:05:34.740,00:05:36.380
Now the model is clear.,00:05:36.380,00:05:37.730
"I store them in a
binary search tree.",00:05:37.730,00:05:40.067
"These are the only
things I'm allowed to do.",00:05:40.067,00:05:41.900
Could I imagine beating log n?,00:05:46.520,00:05:50.630
"Well, no in the worst case.",00:05:50.630,00:05:54.860
"This is best possible
in the worst case.",00:05:54.860,00:05:56.630
Why?,00:06:02.930,00:06:04.310
"Because your tree has
to have depth at least",00:06:04.310,00:06:06.850
"log n if you're going to store
n things, and if it's binary.",00:06:06.850,00:06:10.550
"So your adversary could
always be, could always just",00:06:10.550,00:06:12.895
"look at your tree
and say, Oh I'm",00:06:12.895,00:06:14.270
"going to pick anybody who's
a log in depth or lower,",00:06:14.270,00:06:18.214
"and if you're going
to start at the root",00:06:18.214,00:06:19.880
"and walk left and
right to get there,",00:06:19.880,00:06:21.447
"you're going to have
to pay log n time",00:06:21.447,00:06:23.030
"every single, every
single operation.",00:06:23.030,00:06:27.010
"So actually there's a lot
of sequences, in fact,",00:06:27.010,00:06:29.010
most sequences.,00:06:29.010,00:06:29.635
"You take an average sequence,
this will be the case.",00:06:29.635,00:06:32.870
"But we'll see formal ways
to prove that next class.",00:06:32.870,00:06:36.840
"But, easy adversary
argument tells you",00:06:36.840,00:06:38.720
"you need to go down,
log n in the worst case.",00:06:38.720,00:06:42.210
"But, that's the worst case.",00:06:44.900,00:06:48.180
"The name of the game
in dynamic optimality",00:06:48.180,00:06:50.150
"is to consider every case
separately, and do as",00:06:50.150,00:06:53.660
well as you can all the time.,00:06:53.660,00:06:55.070
"In general, the answer
to this question is that,",00:06:55.070,00:06:58.190
is log n best possible?,00:06:58.190,00:07:00.350
Depends on the access sequence.,00:07:00.350,00:07:03.519
"Depends on what
you're searching for.",00:07:03.519,00:07:05.060
"So, let's say we're, to
make things a little clean,",00:07:15.750,00:07:23.310
"let's assume that the
key is we're storing are",00:07:23.310,00:07:26.640
"the numbers,
integers, one up to n.",00:07:26.640,00:07:30.132
"So in particular
there's n of them.",00:07:30.132,00:07:31.590
"And really we just
care about their order,",00:07:31.590,00:07:33.630
"so I'm going to relabel
them to be one up to n.",00:07:33.630,00:07:37.080
"And say we search for x 1
first, then we search for x 2,",00:07:37.080,00:07:46.620
"and so on, up to x m.",00:07:46.620,00:07:51.060
"So, these indices
are time, basically.",00:07:51.060,00:07:54.300
"Over time, and you can
plot this if you like.",00:07:54.300,00:07:57.350
Here is time.,00:07:57.350,00:07:59.900
Here is space.,00:07:59.900,00:08:02.440
"So at the first time
unit we search at x 1,",00:08:02.440,00:08:07.830
"then some other place,
then some other place.",00:08:07.830,00:08:11.100
"We can have repeats, whatever.",00:08:11.100,00:08:15.590
OK.,00:08:15.590,00:08:16.380
"Some search sequences
are going to be slow,",00:08:16.380,00:08:19.440
"they're going to require
log n time per access.",00:08:19.440,00:08:21.630
"In particular, if I always,
if the adversary chooses",00:08:21.630,00:08:23.970
"x i to be the deepest node
in the tree repeatedly.",00:08:23.970,00:08:27.180
"But some search sequences
are going to be fast.",00:08:27.180,00:08:29.475
"Any suggestions, if you don't
have the notes in front of you,",00:08:33.240,00:08:37.049
"of access sequences that we
can do in less than log n",00:08:37.049,00:08:42.344
time per operation.,00:08:42.344,00:08:43.135
Let's A constant.,00:08:43.135,00:08:46.150
"There's a lot of possible
answers, I think.",00:08:46.150,00:08:48.410
Yeah?,00:08:54.710,00:08:55.210
AUDIENCE: N divided by two.,00:08:55.210,00:08:57.170
PROFESSOR: N divided by two.,00:08:57.170,00:08:59.180
What do you mean.,00:08:59.180,00:09:01.070
"AUDIENCE: Like it's
going to be [INAUDIBLE]",00:09:01.070,00:09:04.939
"PROFESSOR: Oh, if you're
searching for the median",00:09:04.939,00:09:06.980
in a perfectly balanced tree?,00:09:06.980,00:09:08.680
"Yeah, that's true.",00:09:08.680,00:09:10.959
"So if you're always searching
for the root of the tree,",00:09:10.959,00:09:13.250
"in particular, that's
going to be good.",00:09:13.250,00:09:17.120
"That's hard to, that
depends on the tree though.",00:09:17.120,00:09:19.430
"I'd like a particular
access sequence",00:09:19.430,00:09:21.710
"that I can always serve
as well, with some tree.",00:09:21.710,00:09:27.450
AUDIENCE: n order walk.,00:09:27.450,00:09:28.830
PROFESSOR: n order walk.,00:09:28.830,00:09:29.840
"Yeah, good.",00:09:29.840,00:09:31.620
So this has a name.,00:09:31.620,00:09:37.440
Sequential access property.,00:09:37.440,00:09:38.850
"If you want to access the
elements in order, so one",00:09:46.870,00:09:51.200
"through n, this should only
cost constant amortized.",00:09:51.200,00:09:56.520
"Because for any tree
you can do and in order",00:10:02.737,00:10:04.570
walk in linear time.,00:10:04.570,00:10:06.220
"And so per search, if you're
careful about how you do this,",00:10:06.220,00:10:10.690
"now this is not totally obvious
in the model that I've set up,",00:10:10.690,00:10:14.860
"because I said search
always starts at the root.",00:10:14.860,00:10:17.690
"If you let your search
start where you left off,",00:10:17.690,00:10:20.260
then you can definitely do this.,00:10:20.260,00:10:22.570
"It turns out you can
assume this or not,",00:10:22.570,00:10:24.760
it doesn't make a difference.,00:10:24.760,00:10:26.350
That's maybe a fun exercise.,00:10:26.350,00:10:27.607
"But if, you can essentially
reroute the tree",00:10:27.607,00:10:29.440
to be wherever you left off.,00:10:29.440,00:10:31.842
"I'm not going to
prove that here.",00:10:31.842,00:10:34.250
"OK, but in particular, some
trees have this property.",00:10:34.250,00:10:38.920
Some don't.,00:10:38.920,00:10:39.610
"I mean if you use a red black
tree, and you search for one,",00:10:39.610,00:10:42.068
"then search for two,
then search for n,",00:10:42.068,00:10:43.780
"you're not going to
get constant amortized,",00:10:43.780,00:10:45.610
"because it doesn't
realize this is happening.",00:10:45.610,00:10:47.750
"But if you're clever, of
course, this can be achieved.",00:10:47.750,00:10:51.616
"Easy way to see
how to achieve it",00:10:51.616,00:10:52.990
"is, this is your
binary search tree.",00:10:52.990,00:10:57.500
"You access one, then
you do a rotation",00:10:57.500,00:11:00.160
with the right child of one.,00:11:00.160,00:11:01.920
"So then you have this
binary search tree,",00:11:01.920,00:11:05.350
"and then you access two,
and then you do a rotation.",00:11:05.350,00:11:09.970
"This is basically a
way to make a deck.",00:11:09.970,00:11:14.710
"View a, use a link, simulate a
linked list in a binary search",00:11:14.710,00:11:18.880
tree.,00:11:18.880,00:11:20.260
"OK, so it definitely can be
done by some binary search tree.",00:11:20.260,00:11:24.860
"A stronger version of the
sequential access property,",00:11:24.860,00:11:28.305
"it's a little more interesting,
is dynamic finger property.",00:11:28.305,00:11:32.800
"This is something that should
hold for every access sequence,",00:11:32.800,00:11:35.740
"and it gives you a measure
of how expensive an access",00:11:35.740,00:11:38.200
sequence is.,00:11:38.200,00:11:39.820
"So we're doing x
one x two up to x m.",00:11:39.820,00:11:43.240
"And we say, if we
measure the key distance",00:11:43.240,00:11:50.350
"between our current access,
x i and the previous access,",00:11:50.350,00:11:53.770
x i minus 1.,00:11:53.770,00:11:55.290
"If that equals k,
then ideally we",00:11:55.290,00:11:59.500
"should be able to do log
k amortize per operation.",00:11:59.500,00:12:03.670
"So in the worst
case this is going",00:12:06.184,00:12:07.600
"to be log n, but if I look
at my space-time diagram",00:12:07.600,00:12:12.940
"here, if for example, if
I do sequential access,",00:12:12.940,00:12:17.950
"then this number is always one,
and so I get constant time.",00:12:17.950,00:12:21.850
"If I do something like this,
where my spatial distance is",00:12:21.850,00:12:26.920
"not changing too much,
and this is the reason",00:12:26.920,00:12:28.930
I numbered the keys like this.,00:12:28.930,00:12:31.060
"What I really mean is, in
the sorted order of the keys,",00:12:31.060,00:12:33.700
how do the ranks differ.,00:12:33.700,00:12:35.410
"But if I number the
keys one through n,",00:12:35.410,00:12:37.720
"that's just their
absolute difference.",00:12:37.720,00:12:40.589
"So anything like
this, dynamic finger",00:12:40.589,00:12:42.130
"properly tells you
you're doing well.",00:12:42.130,00:12:45.874
"Dynamic finger property can
be achieved by a binary search",00:12:45.874,00:12:48.290
"tree, but it's quite difficult
as you might imagine.",00:12:48.290,00:12:51.540
"Or it's difficult, let's say
not necessarily super hard.",00:12:51.540,00:12:56.400
"If you don't need to do it in
a binary search tree model,",00:12:56.400,00:12:58.980
"an easy way to do
it is with what's",00:12:58.980,00:13:01.290
called a level linked tree.,00:13:01.290,00:13:02.490
"So a level link tree
looks like this,",00:13:04.849,00:13:06.390
"and I add pointers
between adjacent nodes",00:13:06.390,00:13:08.940
in the same level.,00:13:08.940,00:13:10.282
"This is a pointer
machine data structure,",00:13:10.282,00:13:11.990
"it's not a binary search
tree, because binary search",00:13:11.990,00:13:14.340
"trees we only allowed to do walk
left, walk right, walk parent,",00:13:14.340,00:13:18.120
"But it's an easy way
to do dynamic finger.",00:13:18.120,00:13:20.470
"You start from
somewhere, you basically",00:13:20.470,00:13:23.400
"walk up to the right level,
move over, walk back down,",00:13:23.400,00:13:27.630
"and you can do a search for x
i from x i minus one relatively",00:13:27.630,00:13:33.840
quickly.,00:13:33.840,00:13:34.470
"It turns out this can be
stimulated by a binary search",00:13:34.470,00:13:36.720
"tree, but we won't
go into it here.",00:13:36.720,00:13:38.970
Lots of fun puzzles here.,00:13:38.970,00:13:42.040
"Let's move on to some
more bounds or properties.",00:13:42.040,00:13:50.190
"So, next property is called
the entropy property,",00:13:58.320,00:14:01.890
or entropy bound.,00:14:01.890,00:14:04.010
"And it says if key k appears
p sub k fraction of the time,",00:14:04.010,00:14:17.310
"then I'd like to achieve
a bound of entropy p",00:14:17.310,00:14:26.640
"k log one over p
k per operation.",00:14:26.640,00:14:31.290
"This is, everything here
today will be amortized.",00:14:31.290,00:14:34.072
"So, if you haven't seen
entropy, that's the definition.",00:14:36.780,00:14:39.905
"It's the entropy of
this distribution.",00:14:39.905,00:14:41.970
"We're thinking of
these as probabilities,",00:14:41.970,00:14:44.040
"although they're not
really probabilities.",00:14:44.040,00:14:46.870
"They're, because this is
over a particular sample.",00:14:46.870,00:14:51.150
"We have this sequence x1 to x
n, There's no randomness here,",00:14:51.150,00:14:54.670
"but we just measure
what is the fraction,",00:14:54.670,00:14:56.610
"what is sort of the observed
probability for each of these x",00:14:56.610,00:14:59.380
i's.,00:14:59.380,00:15:00.210
"And then just say,
what is the, what",00:15:00.210,00:15:03.120
"is the entropy of
that distribution?",00:15:03.120,00:15:04.620
"In the worst case
it's log n, if say",00:15:04.620,00:15:06.870
"everybody's equally likely,
everyone's accessed once,",00:15:06.870,00:15:09.640
or the same number of times.,00:15:09.640,00:15:11.730
"But if it's highly
skewed, like if only one",00:15:11.730,00:15:14.130
"element is accessed, the
entropy will be constant.",00:15:14.130,00:15:16.479
"If a small number of
elements are accessed,",00:15:16.479,00:15:18.270
entropy will be constant.,00:15:18.270,00:15:19.311
"So this can be
achieved, and in fact,",00:15:21.940,00:15:24.090
"if you disallow
rotations, so if I change",00:15:24.090,00:15:27.270
"the model to forbid
rotations, all I get to do",00:15:27.270,00:15:29.700
"is set up some
binary search tree,",00:15:29.700,00:15:31.740
"and then I have to walk left,
walk right, walk parent,",00:15:31.740,00:15:34.460
"from in that binary
search tree to do this.",00:15:34.460,00:15:37.680
"So if I get to
see the x i's then",00:15:37.680,00:15:39.900
"I get to build a
binary search tree.",00:15:39.900,00:15:43.020
One binary search tree.,00:15:43.020,00:15:45.210
"This is what's called
the static optimal, when",00:15:45.210,00:15:47.160
"you're not allowed to change the
tree as you're doing searches.",00:15:47.160,00:15:50.310
"Entropy is the best
bound you can get.",00:15:50.310,00:15:52.730
"And roughly speaking, key k
appears at height, or depth,",00:15:52.730,00:15:57.990
"log one over p k in the
tree, maybe plus one.",00:15:57.990,00:16:01.470
"And you can show there's always
a tree where every node ends up",00:16:01.470,00:16:06.480
at depth log one over p k.,00:16:06.480,00:16:08.580
"Again, not hard, but
we won't do it here.",00:16:08.580,00:16:13.470
"OK, a related property,
it's called the working set",00:16:13.470,00:16:19.030
property.,00:16:19.030,00:16:19.530
Little bit harder to state.,00:16:28.770,00:16:30.120
"For each search we
do x i, we're going",00:17:03.020,00:17:06.290
"to see when that's some key,
when was the last time that key",00:17:06.290,00:17:10.970
was accessed.,00:17:10.970,00:17:12.180
"So, in our space-time diagram
we have some access at time i,",00:17:12.180,00:17:19.215
"we want to look backwards
in time to the last time",00:17:19.215,00:17:21.980
that key was accessed.,00:17:21.980,00:17:24.319
"Say that was, well some other
time j, and in this interval",00:17:24.319,00:17:30.860
"we want to know, how many
distinct keys were accessed.",00:17:30.860,00:17:36.560
"So it's at most, i
minus j, but maybe there",00:17:36.560,00:17:41.060
"were some repeated accesses,
we only count those as one.",00:17:41.060,00:17:44.340
"So how many different
keys were accessed",00:17:44.340,00:17:46.970
during that time interval?,00:17:46.970,00:17:48.500
"Claim is, we only have
to pay log of that.",00:17:48.500,00:17:52.260
"So what this means, what this
implies, is in particular,",00:17:52.260,00:17:54.880
"if you're only accessing say
k different elements at all,",00:17:54.880,00:17:59.690
"and you ignore all
the other elements,",00:17:59.690,00:18:01.380
"then you'll only pay
log k per operation.",00:18:01.380,00:18:03.867
"That's why it's sort
of a working set.",00:18:03.867,00:18:05.450
"If you're focusing
your attention",00:18:05.450,00:18:06.825
"on k elements for a
while, you only pay log k.",00:18:06.825,00:18:10.430
"But in general, for any access
sequence you can compute,",00:18:10.430,00:18:12.860
"what is the working
set costs, which",00:18:12.860,00:18:14.360
"is you sum over all
the i's of log t i,",00:18:14.360,00:18:17.540
"that is your total cost
for the access sequence.",00:18:17.540,00:18:19.940
"Divide by n, that's
the amortized cost.",00:18:19.940,00:18:23.470
OK?,00:18:23.470,00:18:24.920
"That's another
nice property, not",00:18:24.920,00:18:26.390
"so obvious is that working
set implies the entropy bound,",00:18:26.390,00:18:30.240
so this is a stronger property.,00:18:30.240,00:18:33.350
"I guess dynamic finger
implies sequential access,",00:18:33.350,00:18:36.800
"but there's no relation between
working set and dynamic finger.",00:18:36.800,00:18:40.950
"In fact, they're kind of
transposes of each other.",00:18:40.950,00:18:43.760
"Working set is
about, if you access",00:18:43.760,00:18:46.030
"a key that was accessed
recently, then it's fast.",00:18:46.030,00:18:49.520
"Dynamic finger is
saying, if you access",00:18:49.520,00:18:51.470
"a key that is close in space
to the previous access,",00:18:51.470,00:18:56.330
"so here we're looking
at a key and basically",00:18:56.330,00:18:59.240
"in the very previous
time step we're",00:18:59.240,00:19:01.880
"looking at how far
away it was vertically,",00:19:01.880,00:19:04.400
"here we're looking at how
far away it was horizontally.",00:19:04.400,00:19:07.100
"So they're almost
duals of each other.",00:19:07.100,00:19:09.680
"Be nice if you could
have one property that",00:19:09.680,00:19:12.200
"included both dynamic
finger and working set.",00:19:12.200,00:19:15.710
"I should mention, again
this is not obvious",00:19:15.710,00:19:17.810
"how to do it with a
binary search tree,",00:19:17.810,00:19:19.700
but it can be done.,00:19:19.700,00:19:21.570
Leave it at that.,00:19:21.570,00:19:22.840
"We'll see eventually
some trees that have it.",00:19:22.840,00:19:25.220
"For now I just
want to cover what",00:19:28.586,00:19:29.960
"are the conceivable
goals we should aim for.",00:19:29.960,00:19:32.940
"All right, log n is too easy, so
we need more challenging goals.",00:19:32.940,00:19:36.230
"So the next property,
it was introduced,",00:19:39.380,00:19:41.870
"this is we're getting into
more recent territory, 2001,",00:19:41.870,00:19:48.710
"it's called the
unified property.",00:19:48.710,00:19:50.870
"Natural name, and it tries
to unify dynamic finger",00:19:50.870,00:19:54.770
with working set.,00:19:54.770,00:19:57.560
"And the rough idea
is, that if you",00:19:57.560,00:19:59.330
"access a key that
is close in space",00:19:59.330,00:20:02.630
"to a key that was
accessed recently in time,",00:20:02.630,00:20:05.300
then your access should be fast.,00:20:05.300,00:20:08.010
"So, here's the formal statement.",00:20:08.010,00:20:11.225
So here's the unified bound.,00:20:56.790,00:21:00.210
Let's draw a picture.,00:21:00.210,00:21:03.060
"So here we're accessing
x i at time i, sorry j.",00:21:03.060,00:21:11.740
Change of notation.,00:21:11.740,00:21:14.430
Time j.,00:21:14.430,00:21:14.930
"We want to evaluate
the cost of x j,",00:21:14.930,00:21:18.260
"and we're basically
going to look in--",00:21:18.260,00:21:22.840
"I guess one way to think
of it is this cone.",00:21:22.840,00:21:26.750
"90 degree cone, where
these are 45 degree angles.",00:21:26.750,00:21:31.010
And if there's something--,00:21:31.010,00:21:33.590
"and look at the first thing
that you hit in that cone.",00:21:33.590,00:21:37.310
"Is that the right
way to think of it?",00:21:37.310,00:21:38.960
Maybe not.,00:21:38.960,00:21:41.150
"It's like you're growing a box,
this is probably more accurate,",00:21:41.150,00:21:44.810
"and you find the first key
that you hit in that box.",00:21:44.810,00:21:47.012
"It's a little more
subtle than that",00:21:47.012,00:21:48.470
"because we're only
counting distinct keys,",00:21:48.470,00:21:50.980
"and let's say you find this
key, and this key is good",00:21:50.980,00:21:55.130
"because it's temporal distance,
this time, is only this big.",00:21:55.130,00:22:03.470
"It's spatial distance
is only this big.",00:22:03.470,00:22:05.600
"What we're going to
pay is, log of the sum",00:22:05.600,00:22:08.600
"of the spatial distance,
and the temporal distance.",00:22:08.600,00:22:11.996
"And temporal
distance is measured",00:22:11.996,00:22:13.370
"as the number of distinct keys
accessed in this time interval.",00:22:13.370,00:22:16.640
"So, as long as there is some
key in the recent past that",00:22:19.560,00:22:23.810
"is close in space, you take
the min over all such keys,",00:22:23.810,00:22:28.040
"magically a unified
structure has",00:22:28.040,00:22:29.810
"to find what is the
most recent close item",00:22:29.810,00:22:33.050
"and search from there,
and achieve log of that.",00:22:33.050,00:22:35.860
"There's a plus 2 just to make
sure if these things are zero,",00:22:35.860,00:22:38.960
you still get a constant.,00:22:38.960,00:22:41.180
"Always have to
pay constant time.",00:22:41.180,00:22:44.390
"OK, so that's a
unified property.",00:22:44.390,00:22:46.970
"Fairly natural generalization of
dynamic finger and working set.",00:22:46.970,00:22:51.380
"I mean you could change this
plus to a product or a max,",00:22:51.380,00:22:54.270
doesn't make a difference.,00:22:54.270,00:22:55.727
Yeah.,00:22:59.070,00:23:00.380
"Sadly we don't
know whether there",00:23:00.380,00:23:01.760
"is any binary search tree that
achieves the unified property.",00:23:01.760,00:23:05.720
"What we know is that
this can be done,",00:23:05.720,00:23:09.020
"this property can be achieved
by a pointer machine data",00:23:09.020,00:23:15.140
"structure, which is more
powerful than a binary search",00:23:15.140,00:23:18.001
tree.,00:23:18.001,00:23:18.500
"But we don't know whether
it's possible to achieve",00:23:24.100,00:23:29.060
by a binary search tree.,00:23:29.060,00:23:32.390
"Best bound so far, is
that you can achieve",00:23:32.390,00:23:36.470
this bound plus log log n.,00:23:36.470,00:23:39.170
"So as long as this
never gets too small,",00:23:39.170,00:23:41.725
"as long as this quantity
never gets smaller than log n,",00:23:41.725,00:23:44.430
"then this thing will be
log log n, and it's fine.",00:23:44.430,00:23:47.066
"But in particular,
if this is constant,",00:23:47.066,00:23:48.690
"then it's only achieving
log log n, so it's not--",00:23:48.690,00:23:51.670
"there's an additive log
log n per operation loss.",00:23:51.670,00:23:55.230
"That's the best binary
search, unified binary search",00:23:55.230,00:23:57.430
tree known.,00:23:57.430,00:23:57.929
"OK, so this is all good.",00:24:00.520,00:24:04.090
"And this is sort of where the,
what we call analytic bounds,",00:24:04.090,00:24:08.030
here ends.,00:24:08.030,00:24:10.610
There are various attempts to--,00:24:10.610,00:24:12.002
"in general we want
to characterize,",00:24:12.002,00:24:13.460
"what is the optimal
thing we could hope for.",00:24:13.460,00:24:17.720
"When can we do
better than log n?",00:24:17.720,00:24:19.640
"These are all
specific cases where",00:24:19.640,00:24:21.140
"we can do better than
log n, but it's not",00:24:21.140,00:24:22.848
a complete characterization.,00:24:22.848,00:24:24.520
"There are sequences that
have large unified bound,",00:24:24.520,00:24:27.410
but have no--,00:24:27.410,00:24:29.165
"yet they can be
accessed more quickly",00:24:31.730,00:24:33.740
"by the optimal
binary search tree.",00:24:33.740,00:24:35.624
"And so, while it would
be nice to characterize",00:24:35.624,00:24:37.540
"with some clean algebraic,
whatever, most of the work,",00:24:37.540,00:24:41.780
"beyond what I've
told you about here,",00:24:41.780,00:24:43.970
"is just trying to
figure out what opt is.",00:24:43.970,00:24:46.400
"Instead of trying to write
it down, try to compute it.",00:24:46.400,00:24:50.259
"Instead of trying
to define something",00:24:50.259,00:24:51.800
"that happens to
match the optimal,",00:24:51.800,00:24:53.690
let's just go for optimal.,00:24:53.690,00:24:56.100
"And this is the notion
of dynamic optimality.",00:24:56.100,00:24:58.433
"And in modern
terminology this would",00:25:02.510,00:25:04.090
"be called constant
competitive, but the paper then",00:25:04.090,00:25:09.860
"introduced dynamic optimality
preceded competitive analysis,",00:25:09.860,00:25:13.145
so it has another name.,00:25:13.145,00:25:15.980
"What we'd like, is that
the total cost of all",00:25:15.980,00:25:19.550
"your accesses, so this
is like amortized cost,",00:25:19.550,00:25:22.530
"is within a constant
factor of the optimal.",00:25:22.530,00:25:26.920
What's the optimal?,00:25:26.920,00:25:29.240
"This is the-- over all
binary search trees,",00:25:29.240,00:25:33.080
"I mean to be precise I should
talk about binary search tree",00:25:33.080,00:25:35.720
"algorithms, meaning you specify
somehow how to do a search,",00:25:35.720,00:25:39.500
"and it may involve
rotations and walks.",00:25:39.500,00:25:41.900
"So, you know, it could
be red black tree,",00:25:41.900,00:25:44.510
"it could be an AVL tree,
could be a [? BB ?] alpha",00:25:44.510,00:25:46.700
"tree, anything that can be
implemented in this way.",00:25:46.700,00:25:49.640
Those are all kind of boring.,00:25:49.640,00:25:52.330
"More sophisticated is
something like a splay tree.",00:25:52.330,00:25:55.850
"Ideally, you take
the min over all--",00:25:55.850,00:25:59.915
"min over all binary
search tree algorithms.",00:26:02.840,00:26:06.710
"The cost of that algorithm, on
that access sequence x, and you",00:26:06.710,00:26:13.820
"want the total cost
of your algorithm",00:26:13.820,00:26:15.740
"on x to be within a constant
factor of the optimal algorithm",00:26:15.740,00:26:19.760
on x.,00:26:19.760,00:26:20.780
x is a vector.,00:26:20.780,00:26:23.610
"So this is what you call
the offline optimal,",00:26:23.610,00:26:26.540
"because here you basically get
to choose the binary search",00:26:26.540,00:26:29.600
"tree algorithm to
be customized to x,",00:26:29.600,00:26:33.800
"and yet somehow you want to
achieve dynamic optimality.",00:26:33.800,00:26:40.310
"Open question, is this possible?",00:26:40.310,00:26:43.970
"And, of course, we're only
interested in online solutions.",00:26:53.990,00:26:57.330
"So, you want to build a
binary search tree that",00:26:57.330,00:26:59.432
"doesn't know the
future, it doesn't",00:26:59.432,00:27:00.890
"know what accesses
are to come, but it",00:27:00.890,00:27:02.750
"has to be within a constant
factor of the offline solution",00:27:02.750,00:27:06.020
that does know.,00:27:06.020,00:27:07.928
"And we don't know
whether this is possible.",00:27:07.928,00:27:10.160
"Another interesting
question, is whether it's",00:27:10.160,00:27:12.530
"possible for a pointer
machine, because save",00:27:12.530,00:27:17.634
"for the unified property
we know how to get it",00:27:17.634,00:27:19.550
for a pointer machine.,00:27:19.550,00:27:21.980
"And there's two versions
of this question.",00:27:21.980,00:27:23.730
"You can consider, is
there a pointer machine",00:27:23.730,00:27:25.970
"that matches the optimal
binary search tree,",00:27:25.970,00:27:28.096
"or you could ask, is there a
pointer machine that matches",00:27:28.096,00:27:30.470
the optimal pointer machine.,00:27:30.470,00:27:31.779
"That's a little less defined,
although there are some--",00:27:31.779,00:27:34.070
"I have some ideas on how to
define that problem, maybe will",00:27:34.070,00:27:36.528
work on it.,00:27:36.528,00:27:37.460
"But all versions of this
problem are open, basically.",00:27:37.460,00:27:41.360
"So, this may seem
rather depressing.",00:27:41.360,00:27:43.580
"What else am I going to do
for a lecture and a half?",00:27:43.580,00:27:46.472
"But actually, there's a lot
of study of this problem,",00:27:46.472,00:27:48.680
and we do know some good things.,00:27:48.680,00:27:50.013
"For example, we can get
log log n competitive.",00:27:50.013,00:27:56.907
"So, not within a
constant factor,",00:28:00.890,00:28:02.540
"but we can get within a log
log n factor of the optimal.",00:28:02.540,00:28:06.480
"So, that's pretty good.",00:28:06.480,00:28:07.785
"An easy result is to
get log n competitive.",00:28:07.785,00:28:11.644
"Any balanced binary
search tree is log n",00:28:11.644,00:28:13.310
"competitive, because best case
you could hope for is constant,",00:28:13.310,00:28:16.070
"the worst case you
can hope for is log n.",00:28:16.070,00:28:18.160
"So at least within
the log factor,",00:28:18.160,00:28:19.962
"but we can do
exponentially better.",00:28:19.962,00:28:21.420
We'll do that next class.,00:28:21.420,00:28:24.560
"Before we go there, I want to
tell you about two structures,",00:28:24.560,00:28:31.820
"to binary search trees that
we conjecture are dynamically",00:28:31.820,00:28:36.110
"optimal, but we can't prove it.",00:28:36.110,00:28:38.030
"So first one, and the classic
one, is splayed trees.",00:29:01.300,00:29:03.890
"I don't want to spend too
much time on splay trees,",00:29:03.890,00:29:06.790
"but just to let you know what
they are if you don't already",00:29:06.790,00:29:09.920
know.,00:29:09.920,00:29:11.270
"If you want to search
for x, you search for x.",00:29:11.270,00:29:14.900
"You do a binary search
for x in the tree.",00:29:14.900,00:29:17.750
"You locate x, and then you--",00:29:17.750,00:29:19.930
"splay trees always
move x to the root.",00:29:19.930,00:29:24.270
"So, this is what we call
a self-adjusting tree.",00:29:24.270,00:29:27.230
"It changes the structure of
the tree as you do searches,",00:29:27.230,00:29:30.170
"not just when you're
doing updates,",00:29:30.170,00:29:34.160
and there are two cases.,00:29:34.160,00:29:36.570
"If you look at x, and its
parent and its grandparent,",00:29:36.570,00:29:39.200
"if they're oriented
the same way.",00:29:39.200,00:29:40.650
"So, here it's two left pointers,
could be two right pointers.",00:29:40.650,00:29:44.180
Then you flip them.,00:29:44.180,00:29:46.850
"So we rotate y, and then rotate
x, so it's in this model.",00:29:46.850,00:29:57.660
"And we get x y z
in the other order.",00:29:57.660,00:30:02.660
"There's pretty much
only one way to move",00:30:02.660,00:30:04.610
x to the root in that picture.,00:30:04.610,00:30:06.170
"Then the other case is
the zigzag case, y, w, x.",00:30:09.020,00:30:17.255
"So, here the two parent pointers
are in different directions,",00:30:20.330,00:30:22.890
"one is left, one is right.",00:30:22.890,00:30:24.530
There's a symmetric picture.,00:30:24.530,00:30:26.520
"In this case, we rotate
in the other order.",00:30:26.520,00:30:29.760
"So, we rotate x, and
then we rotate y.",00:30:29.760,00:30:32.900
"And in that case you get x
nice, x, w, y, and the subtrees",00:30:35.930,00:30:44.465
hang off.,00:30:44.465,00:30:45.015
"I'm not labeling the
subtrees, but they",00:30:45.015,00:30:46.640
"have to be labeled in the
same order, left to right.",00:30:46.640,00:30:50.940
"OK, this is splay trees.",00:30:50.940,00:30:52.130
"You do this for x. x is
the thing you search for,",00:30:52.130,00:30:56.360
"now x is up here,
then you repeat.",00:30:56.360,00:30:58.460
"You look at it's two parents,
it's one of these two cases,",00:30:58.460,00:31:01.410
"you do the appropriate
two rotations.",00:31:01.410,00:31:03.650
"Until x is either the
root, and you're done,",00:31:03.650,00:31:05.662
"or it's one child from
the root, and then",00:31:05.662,00:31:07.370
"you do one rotation
to make it the root.",00:31:07.370,00:31:09.036
Seems simple enough.,00:31:12.040,00:31:14.120
"It's slightly more sophisticated
than an algorithm known as move",00:31:14.120,00:31:17.290
"to root, which is just
rotate x, rotate x,",00:31:17.290,00:31:19.780
"rotate x, which would
eventually propagate it up.",00:31:19.780,00:31:22.450
"Move to root is a
really bad algorithm.",00:31:22.450,00:31:24.190
"It can show its can be a
factor of square root of n.",00:31:24.190,00:31:26.770
"It can be square root of n per
operation if you're unlucky.",00:31:26.770,00:31:30.760
"Splay trees are always, at most
log n amortized per operation,",00:31:30.760,00:31:34.510
"although that's
not at all obvious.",00:31:34.510,00:31:36.310
"Rough intuition, is if you
look at the path, the route",00:31:36.310,00:31:39.670
"to x path, half of the nodes,
at most half of the nodes",00:31:39.670,00:31:44.740
go down when you splay.,00:31:44.740,00:31:47.650
So why is that?,00:31:47.650,00:31:49.030
"Here, see y stays
at the same level.",00:31:49.030,00:31:52.250
"z goes down, but x goes up.",00:31:52.250,00:31:55.150
"Here, w stays at the same level,
x goes up, y goes down by one,",00:31:55.150,00:32:00.710
"x goes up by two, so you might
call that a net improvement.",00:32:00.710,00:32:04.060
"But in general you don't
mess up the path too much.",00:32:04.060,00:32:06.940
"Half the items stay
where they are,",00:32:06.940,00:32:09.320
"and so it's something
like your bisecting--",00:32:09.320,00:32:12.400
"if you repeatedly
search for x, well",00:32:12.400,00:32:14.155
"I'm not really searching
for x, but if you repeatedly",00:32:14.155,00:32:16.090
"search for things
in that path, you're",00:32:16.090,00:32:17.673
"kind of cutting the path
and half repeatedly.",00:32:17.673,00:32:19.550
"It'll look kind of logarithmic,
that's a very vague argument.",00:32:19.550,00:32:23.710
"And in the advanced
algorithms, it's",00:32:23.710,00:32:25.930
"proved why this is
log n amortized.",00:32:25.930,00:32:27.790
Question?,00:32:27.790,00:32:28.707
AUDIENCE: [INAUDIBLE],00:32:28.707,00:32:35.180
"PROFESSOR: Rotate x, rotate
x, I think you're right.",00:32:35.180,00:32:38.350
"Yeah, y would go
somewhere else, thanks.",00:32:38.350,00:32:42.390
"Yeah, so here it looks like
move to root, here it doesn't.",00:32:42.390,00:32:48.580
"Good, and there's lots of
things known about splay trees.",00:32:48.580,00:32:52.430
"So for example, they satisfy
the sequential access property.",00:32:52.430,00:32:56.580
"There's an entire paper,
combinatoric on 1985 Tarjan",00:32:56.580,00:33:00.380
"I believe, proving splay trees
have the sequential access",00:33:00.380,00:33:03.860
property.,00:33:03.860,00:33:04.460
"Not at all obvious,
but it's true.",00:33:04.460,00:33:08.120
"They have the
working set property,",00:33:08.120,00:33:10.040
"and therefore they have
the entropy property.",00:33:10.040,00:33:12.400
"That's in the original
splay tree paper.",00:33:12.400,00:33:14.154
It's not that hard to prove.,00:33:14.154,00:33:15.320
"Once you prove log n, with
a little bit more effort",00:33:15.320,00:33:17.840
"you can prove the
working set property.",00:33:17.840,00:33:19.550
We won't do it here.,00:33:19.550,00:33:21.890
It's a cool amortization.,00:33:21.890,00:33:26.660
"Splay trees also have the
dynamic finger property.",00:33:26.660,00:33:29.690
"This is a series of two
papers, over 100 pages long.",00:33:29.690,00:33:33.410
Very difficult to prove.,00:33:33.410,00:33:34.660
"In general, splay trees
are hard to work with,",00:33:34.660,00:33:36.620
"because it's hard to keep
track of what's going on.",00:33:36.620,00:33:39.392
"You can define
potential functions,",00:33:39.392,00:33:40.850
"and that will prove this,
and with a lot of effort",00:33:40.850,00:33:43.070
it will prove this.,00:33:43.070,00:33:44.480
"We don't know whether
splay trees satisfy",00:33:44.480,00:33:46.430
"the unified property,
and more to the point,",00:33:46.430,00:33:48.364
"we don't know whether splay
trees are dynamically optimal.",00:33:48.364,00:33:50.780
"This is the big question, and
in the original splay tree paper",00:33:50.780,00:33:53.900
"it asked this question,
are splay trees",00:33:53.900,00:33:56.210
dynamically optimal.,00:33:56.210,00:33:57.590
"Still open, I wish I knew
the answer, but we don't.",00:33:57.590,00:34:01.700
"So what the rest of today's
lecture is going to be about",00:34:05.390,00:34:08.139
"is a geometric view, which
I've kind of been hinting",00:34:08.139,00:34:12.747
"at with this picture, but
it's, there's more to it",00:34:12.747,00:34:14.830
"than just plot the
points of searches.",00:34:14.830,00:34:18.580
"There's a way, not only to
see what the searches are,",00:34:18.580,00:34:21.159
"but to see what the binary
search tree algorithm is.",00:34:21.159,00:34:24.902
"So, at this point binary
search tree algorithms",00:34:24.902,00:34:26.860
are kind of abstract.,00:34:26.860,00:34:28.090
"I mean, we've kind
of drawn pictures,",00:34:28.090,00:34:29.980
"and how to do
specific cases, you",00:34:29.980,00:34:31.810
"know how red black
trees or something work.",00:34:31.810,00:34:34.850
"But, you know, it's
complicated to write down",00:34:34.850,00:34:36.790
one of these algorithms.,00:34:36.790,00:34:37.789
"How would we think
about all of them?",00:34:37.789,00:34:41.050
"What would you think
about the optimal one?",00:34:41.050,00:34:43.120
"Turns out there's a geometric
view, in which it's actually",00:34:43.120,00:34:45.940
"very easy to see what
the algorithm is,",00:34:45.940,00:34:48.790
"but it takes a
little bit of work",00:34:48.790,00:34:50.500
"to prove that it's
the right thing.",00:34:50.500,00:34:52.750
"And it suggests a totally
obvious offline optimal",00:34:52.750,00:34:57.820
"algorithm, which we
don't know is optimal,",00:34:57.820,00:35:00.850
but we think is offline optimal.,00:35:00.850,00:35:03.940
"It's like the obvious thing
to do, which we'll get to,",00:35:03.940,00:35:10.150
"and we can actually
make it online.",00:35:10.150,00:35:12.100
"So, this is-- this
gives us a binary search",00:35:12.100,00:35:14.350
"tree that is so
obviously optimal,",00:35:14.350,00:35:17.110
"where splay trees is kind
of vaguely feels good,",00:35:17.110,00:35:20.440
"this is really obvious,
yet we can't prove it.",00:35:20.440,00:35:23.275
"So it's like we're one step
closer, but not quite there.",00:35:23.275,00:35:26.710
So that's where we're going.,00:35:29.594,00:35:30.760
"So this geometric view was
the topic of [? Deion ?]",00:35:56.550,00:35:59.250
"[? Harmon's ?] PhD
thesis, here at MIT.",00:35:59.250,00:36:01.740
"And it's also with John Iacono,
[? Danielle ?] [? Caine, ?] who",00:36:01.740,00:36:04.717
"was an undergrad here, and
[? Mihal ?] [? Piotrowski, ?]",00:36:04.717,00:36:07.050
"who was an undergrad
and a PhD here.",00:36:07.050,00:36:09.450
"It was published
three years ago, 2009.",00:36:09.450,00:36:13.890
"So, here's the idea.",00:36:13.890,00:36:17.130
"Access sequence, this is the
sequence of searches you do.",00:36:17.130,00:36:21.780
"That's very easy, you just
map it to the set of points",00:36:21.780,00:36:26.970
"where, I guess I'm going
to switch things on you.",00:36:26.970,00:36:29.910
Sorry about that.,00:36:29.910,00:36:33.030
"X-axis is going to be space,
y-axis is going to be time.",00:36:33.030,00:36:38.280
"And I'm going to look at a
specific example of this.",00:36:38.280,00:36:40.470
Sort of pinwheel.,00:36:44.720,00:36:47.150
"Four accesses at--
the first time",00:36:47.150,00:36:49.820
"we access key three, then
we access key one, then",00:36:49.820,00:36:52.640
"key four, then key two.",00:36:52.640,00:36:54.680
"We've been drawing this
picture throughout the lecture.",00:36:54.680,00:36:57.710
"Now the interesting part, is
if you look at a binary search",00:36:57.710,00:37:02.090
"tree that actually
accesses these elements,",00:37:02.090,00:37:06.870
here's the exciting part.,00:37:06.870,00:37:08.900
"We're going to map this
to a point set, which",00:37:08.900,00:37:14.360
"is which nodes get
touched during a search,",00:37:14.360,00:37:29.570
during each search.,00:37:29.570,00:37:30.800
"OK, this is the fun part.",00:37:37.720,00:37:40.530
"So, what does touched mean?",00:37:40.530,00:37:41.730
"I erased the model, but in
general with a binary search",00:37:41.730,00:37:45.205
"tree, we only have one
pointer into the tree.",00:37:45.205,00:37:47.080
"It starts at the root, it
can go left, it can go right,",00:37:47.080,00:37:49.890
it can go to the parent.,00:37:49.890,00:37:51.570
"Every node that gets
visited during-- it",00:37:51.570,00:37:53.820
"can do rotations,
every node that",00:37:53.820,00:37:55.980
"gets visited by walking, that's
what I call a touched node.",00:37:55.980,00:38:01.590
Just look at all of them.,00:38:01.590,00:38:03.070
"So for example,
in this picture--",00:38:03.070,00:38:05.175
"color-- suppose,
maybe we're lucky,",00:38:11.260,00:38:14.920
and key three is at the root.,00:38:14.920,00:38:17.090
"So that's the only
thing I touch.",00:38:17.090,00:38:20.390
"If that's the case,
when I access one,",00:38:20.390,00:38:22.772
it's definitely not the root.,00:38:22.772,00:38:23.980
"So, in particular, I definitely
have to have touched that node.",00:38:23.980,00:38:29.310
"And I'm just going to fill
in a reasonable choice.",00:38:29.310,00:38:36.370
"I happen to know, this is
a valid binary search tree.",00:38:36.370,00:38:40.310
"Not so obvious, but
you can find one.",00:38:40.310,00:38:42.910
"I'm using here, the
greedy algorithm actually,",00:38:42.910,00:38:45.320
I'm cheating.,00:38:45.320,00:38:46.690
We'll get to what that is.,00:38:46.690,00:38:49.460
"But in general, some point
sets, like this point set,",00:38:49.460,00:38:52.060
are not valid.,00:38:52.060,00:38:53.500
"There's no binary search tree
that has this touch pattern.",00:38:53.500,00:38:56.020
"You just can't jump
around, teleport,",00:38:56.020,00:38:57.790
without getting somewhere.,00:38:57.790,00:39:01.490
"But, this one is valid.",00:39:01.490,00:39:02.740
"So, which ones are valid?",00:39:02.740,00:39:04.029
Oh sorry I need one more point.,00:39:04.029,00:39:05.320
"Which ones are valid,
which ones are invalid?",00:39:08.726,00:39:10.600
"How did I know that
that was invalid,",00:39:10.600,00:39:12.160
and now this one is valid?,00:39:12.160,00:39:14.150
"Well, there's a
theorem tell you.",00:39:14.150,00:39:16.440
"Then what I was just doing
there will become clear.",00:39:16.440,00:39:19.870
"So, I want to know when is
the point set a valid BST",00:39:36.970,00:39:41.940
"execution, and I claim
it is, if and only",00:39:41.940,00:39:47.850
"if, in every rectangle
spanned by two points",00:39:47.850,00:40:07.530
"not on a common horizontal
or vertical line,",00:40:07.530,00:40:26.160
"in every rectangle, there
there's another point.",00:40:26.160,00:40:28.650
"So, let me draw a picture.",00:40:37.710,00:40:39.390
I have some point set.,00:40:39.390,00:40:41.200
"We'll look at this
one in a moment.",00:40:41.200,00:40:43.200
"In general, I take
any two points",00:40:43.200,00:40:44.940
"that are not horizontally
or vertically aligned,",00:40:44.940,00:40:47.640
that spans a rectangle.,00:40:47.640,00:40:50.187
"In other words, the
rectangle with those two",00:40:50.187,00:40:52.020
as opposite corners.,00:40:52.020,00:40:53.850
"There's got to be another
point in there, somewhere.",00:40:53.850,00:40:56.082
"Could be on the boundary,
could be interior.",00:40:56.082,00:40:57.915
"OK, in fact, you can
pump this a little bit.",00:41:00.490,00:41:02.770
"So once I find some point,
let's say on the interior,",00:41:02.770,00:41:05.880
then my picture looks like this.,00:41:05.880,00:41:09.480
"Maybe I'll just
draw it as a circle.",00:41:09.480,00:41:12.970
"Well, here's another rectangle.",00:41:12.970,00:41:14.670
"That one has to have
a point inside it.",00:41:14.670,00:41:16.500
"Here's another
rectangle, that one",00:41:16.500,00:41:18.090
has to have a point inside it.,00:41:18.090,00:41:20.410
"You could keep going, until you
know maybe I'd put one here,",00:41:20.410,00:41:25.590
maybe I put one here.,00:41:25.590,00:41:27.760
"OK if I update the
picture then, I still",00:41:27.760,00:41:30.000
"have a little
rectangle like that,",00:41:30.000,00:41:33.410
"little rectangle like that,
little rectangle like this.",00:41:33.410,00:41:36.600
"At this point, this point
is no longer involved",00:41:36.600,00:41:38.760
"in any rectangles
essentially, because there's",00:41:38.760,00:41:41.749
"no rectangle between
these two points",00:41:41.749,00:41:43.290
"because they're
horizontally aligned.",00:41:43.290,00:41:45.480
"I could finish this off,
finally, by adding points,",00:41:45.480,00:41:50.490
let's say at the corners.,00:41:50.490,00:41:52.350
"Once I add points at the
corners this will be satisfied.",00:41:52.350,00:41:55.860
"We call this property
arborally satisfied.",00:41:55.860,00:41:59.715
Gotta look up the spelling.,00:41:59.715,00:42:01.770
Arboral satisfaction.,00:42:01.770,00:42:06.420
"Arboral means having
to do with a tree.",00:42:06.420,00:42:10.170
"OK, so this is saying that
point set is treelike,",00:42:10.170,00:42:13.560
if it has this property.,00:42:13.560,00:42:15.570
"OK this picture is
getting a little messy,",00:42:15.570,00:42:17.490
"but if I have any monotone path,
like this, this is satisfied.",00:42:17.490,00:42:23.460
"If you look at any rectangle,
say this one, it has points--",00:42:23.460,00:42:27.420
other points in it.,00:42:27.420,00:42:29.170
"OK, if I look at, I
don't know, this one,",00:42:29.170,00:42:31.580
it has another point in it.,00:42:31.580,00:42:32.910
"But look at this one, that one
doesn't count because it's just",00:42:32.910,00:42:35.493
a vertical line.,00:42:35.493,00:42:36.420
So it has to have non-zero area.,00:42:36.420,00:42:39.055
"If you look at any two
points, this one and this one,",00:42:39.055,00:42:41.970
"they span a rectangle, there's
another point in there.",00:42:41.970,00:42:44.340
"So, monotone paths are good.",00:42:44.340,00:42:46.030
This point set.,00:42:46.030,00:42:47.040
"If I drew it correctly, is good.",00:42:47.040,00:42:50.900
"I look at any rectangle here,
it's got another point in it.",00:42:50.900,00:42:54.480
"Takes some practice to be able
to see all the rectangles,",00:42:58.680,00:43:02.670
but check it.,00:43:02.670,00:43:04.134
Eventually this one is good.,00:43:04.134,00:43:05.300
This one's obviously bad.,00:43:05.300,00:43:06.341
"It has lots of wrecked-- we
call these empty rectangles,",00:43:06.341,00:43:08.940
"unsatisfied rectangles, that
have no extra points in them.",00:43:08.940,00:43:12.480
"So, this is a valid BST
execution, this is not.",00:43:12.480,00:43:15.772
"Let's prove this theorem
it's actually not that hard.",00:43:15.772,00:43:17.980
"The consequence
of the theorem, is",00:43:31.470,00:43:33.740
it tells us what we need to do.,00:43:33.740,00:43:37.440
"We are given a
point set like this,",00:43:37.440,00:43:39.440
we want a point set like this.,00:43:39.440,00:43:42.960
"We can define the cost
of a binary search tree",00:43:42.960,00:43:47.510
"to be how many
nodes does it touch.",00:43:47.510,00:43:49.640
"That's within a constant factor
of how many operations you do.",00:43:49.640,00:43:52.890
"If you don't want to,
it's pointless to touch",00:43:52.890,00:43:54.920
"a node more than a
constant number of times.",00:43:54.920,00:43:56.930
You can prove that.,00:43:56.930,00:43:58.220
"So, really we just care about
how many nodes get touched.",00:43:58.220,00:44:02.060
"So, what we want to do is find
a minimum superset of this point",00:44:02.060,00:44:05.360
set that is satisfied.,00:44:05.360,00:44:08.150
"We're given a set to
represent or access",00:44:08.150,00:44:10.230
sequence that is not satisfied.,00:44:10.230,00:44:12.042
"We need to act-- we need
to touch those points.",00:44:12.042,00:44:14.000
That's the definition of search.,00:44:14.000,00:44:16.400
"And now we'd just like to also
touch some other points that",00:44:16.400,00:44:19.010
make it satisfied.,00:44:19.010,00:44:19.760
"This is a geometric
interpretation of dynamic opt.",00:44:19.760,00:44:24.050
"Can you find the
offline optimal, is--",00:44:24.050,00:44:27.152
"what's the minimum
number of points",00:44:27.152,00:44:28.610
"to add in order to make your
point set arborally satisfied.",00:44:28.610,00:44:33.560
"We don't know whether
that problem is NP hard.",00:44:33.560,00:44:35.600
Probably it is.,00:44:35.600,00:44:37.400
We don't know how to compute it.,00:44:37.400,00:44:40.069
"We don't know how to
find a constant factor",00:44:40.069,00:44:41.860
"approximation, unfortunately.",00:44:41.860,00:44:44.690
Yeah?,00:44:44.690,00:44:45.882
"AUDIENCE: So, this is for and
access sequence, so every time",00:44:45.882,00:44:50.450
"corresponds to just
seeking like one",00:44:50.450,00:44:53.399
individually thing in the tree?,00:44:53.399,00:44:54.690
PROFESSOR: Right.,00:44:54.690,00:44:55.410
"AUDIENCE: OK, that
makes more sense.",00:44:55.410,00:44:56.210
"PROFESSOR: Yes, so the input--",00:44:56.210,00:44:58.080
"there is a unique
thing, a key, that",00:44:58.080,00:45:01.370
gets accessed at each time.,00:45:01.370,00:45:03.060
"So if you draw any horizontal
line, in the input point",00:45:03.060,00:45:07.250
"set there's only one point
in each horizontal line.",00:45:07.250,00:45:09.560
"There can be multiple points
in each vertical line, which",00:45:09.560,00:45:12.680
"would mean that key gets
accessed more than one time.",00:45:12.680,00:45:15.436
"That's the obvious
interpretation terms",00:45:15.436,00:45:17.060
"of binary search tree, turns
out you don't need to assume",00:45:17.060,00:45:19.435
either of those things.,00:45:19.435,00:45:20.780
"You could allow a
sort of multi-search,",00:45:20.780,00:45:22.790
"where I say during this round
you have to access key 5 and 7,",00:45:22.790,00:45:26.870
I don't care in what order.,00:45:26.870,00:45:28.730
"Whereas normally I say,
you have access key 5,",00:45:28.730,00:45:31.010
then you have to access key 7.,00:45:31.010,00:45:32.544
"You could do a
multi-search, where",00:45:32.544,00:45:33.960
"there's multiple
points in a single row.",00:45:33.960,00:45:36.920
"All of the things I'll say
work, it doesn't really",00:45:36.920,00:45:39.260
make a difference as the claim.,00:45:39.260,00:45:41.450
"You could also assume that no
key is accessed more than once,",00:45:41.450,00:45:45.740
so then there's only one--,00:45:45.740,00:45:47.270
"those would be the
opposite extreme.",00:45:47.270,00:45:48.860
"You can assume there's
only one key per column.",00:45:48.860,00:45:51.809
"That turns out not to
make much difference.",00:45:51.809,00:45:53.600
"If there's multiple keys
in the same position,",00:45:53.600,00:45:55.700
"just spread them out
a little and you'll",00:45:55.700,00:45:58.220
get roughly the same cost.,00:45:58.220,00:46:00.960
"So, good question.",00:46:00.960,00:46:02.186
"But in the natural
interpretation",00:46:02.186,00:46:03.560
"there's one per row,
multiple per column,",00:46:03.560,00:46:05.268
"but it doesn't,
neither one matters.",00:46:05.268,00:46:06.980
OK.,00:46:09.855,00:46:10.355
"So this becomes the problem,
go from this to this,",00:46:14.210,00:46:17.360
"with a minimum number
of added points.",00:46:17.360,00:46:20.630
"We do know a log log n
approximation to that problem.",00:46:20.630,00:46:24.130
That's the best we know.,00:46:24.130,00:46:26.540
"You just take this
binary search tree,",00:46:26.540,00:46:29.000
"and apply this transformation,
and it tells you",00:46:29.000,00:46:33.170
"if you have a
binary search tree,",00:46:33.170,00:46:34.640
"you can turn it into a way
to satisfy a point set.",00:46:34.640,00:46:37.022
"But this is actually the
best approximation algorithm",00:46:37.022,00:46:39.230
that we know.,00:46:39.230,00:46:40.460
"But as you'll see, the geometric
view offers a lot of insight.",00:46:40.460,00:46:44.060
"Gives us a lot of
power, and in some sense",00:46:44.060,00:46:45.870
we use it to construct this.,00:46:45.870,00:46:49.710
"OK, so let's prove the theorem.",00:46:49.710,00:46:53.485
So there's two directions.,00:47:01.360,00:47:02.660
"We'll start with
the easy direction.",00:47:02.660,00:47:04.670
"If you have a
binary search tree,",00:47:04.670,00:47:06.620
"then it must be
arborally satisfied.",00:47:06.620,00:47:09.404
"Then we'll have
to do the reverse,",00:47:09.404,00:47:10.820
"actually build a binary search
tree out of a point set.",00:47:10.820,00:47:13.190
That's kind of the harder step.,00:47:13.190,00:47:17.120
"So, let's say we
have two points.",00:47:17.120,00:47:19.670
"Let's say this is that
time i, we access key x,",00:47:22.610,00:47:27.860
"and this one is at time
j, we access key y.",00:47:27.860,00:47:31.610
"Let's suppose y
is greater than x,",00:47:31.610,00:47:33.340
there's the symmetric picture.,00:47:33.340,00:47:35.990
"We want to argue that
there is some other point",00:47:35.990,00:47:38.270
in this rectangle.,00:47:38.270,00:47:42.010
"OK, here's the plan, let a be
the lowest common ancestor of x",00:47:42.010,00:47:51.050
and y.,00:47:51.050,00:47:52.700
"x is a key, y is a key,
they are nodes in the tree.",00:47:52.700,00:47:57.110
This is a changing quantity.,00:47:57.110,00:47:58.670
"As the tree wiggles
around those rotations,",00:47:58.670,00:48:01.050
"the least common
ancestor changes.",00:48:01.050,00:48:02.830
"But at every time,
there is, it has",00:48:02.830,00:48:05.911
some of these common ancestor.,00:48:05.911,00:48:07.160
"Might be x, might be y,
might be some other node.",00:48:07.160,00:48:10.250
OK?,00:48:10.250,00:48:11.840
"I want to look at
a couple of things.",00:48:11.840,00:48:13.550
"Let's say, right before
x is touched at time i,",00:48:17.460,00:48:34.200
"or I guess right before time i
would be the proper phrasing.",00:48:34.200,00:48:37.620
"So we're at this moment, I
want to know does a equal x?",00:48:41.970,00:48:47.250
"If a does not equal
x, then I'm going",00:48:51.730,00:48:58.090
to use the point a comma i.,00:48:58.090,00:49:02.240
OK?,00:49:02.240,00:49:02.800
"Least common ancestor has the
property that x is less than",00:49:02.800,00:49:07.870
"or equal to a, is less
than or equal to y.",00:49:07.870,00:49:10.420
"Common ancestor,
least common ancestor",00:49:10.420,00:49:12.250
will be between x and y.,00:49:12.250,00:49:15.760
"And we also know that
it's an ancestor of x,",00:49:15.760,00:49:17.870
and it's an ancestor of y.,00:49:17.870,00:49:19.030
"So, if you're going to
touch x, you must touch a.",00:49:19.030,00:49:22.550
"If you're going to touch
y, you must touch a.",00:49:22.550,00:49:26.260
"So a comma i is going to
be some point here, which",00:49:26.260,00:49:30.520
is what we need.,00:49:30.520,00:49:32.410
"Except, if a equals x, sorry,
what the heck did I do?",00:49:32.410,00:49:41.080
Transposed again.,00:49:41.080,00:49:42.070
"OK, this is time i, time
j, x, y, sorry about that.",00:49:42.070,00:49:49.748
"OK, here's time i, here is a.",00:49:49.748,00:49:54.550
"So, if a does not equal
x, we know at time i,",00:49:54.550,00:49:59.035
"we must access
all ancestor of x,",00:49:59.035,00:50:00.910
"we must touch all ancestors
of x, before we touch x.",00:50:00.910,00:50:04.030
"Therefore, this is
a point and we're",00:50:04.030,00:50:06.130
"done, unless a equals
x at this time,",00:50:06.130,00:50:09.295
"because then it's
the same point.",00:50:09.295,00:50:10.670
"We didn't get a third
point, we at least",00:50:10.670,00:50:12.336
"need to find some different
point other than these two.",00:50:12.336,00:50:15.880
"OK, so that would be good.",00:50:15.880,00:50:17.620
"We can-- so it must actually be
that at this time, at time i,",00:50:17.620,00:50:23.140
a is right here.,00:50:23.140,00:50:25.450
Let's then look at time j.,00:50:25.450,00:50:27.030
"Same deal, at time j,
here's y that gets access.",00:50:32.110,00:50:36.370
We must also access a.,00:50:36.370,00:50:38.620
"Now it could be its equal to y,
or it could be somewhere else.",00:50:38.620,00:50:41.740
"It could be here, or
could be still here.",00:50:41.740,00:50:45.250
"In those cases we're
happy, but this one also",00:50:45.250,00:50:48.730
could have been at the corner.,00:50:48.730,00:50:51.190
"The case we're not happy is when
b equals x, sorry, a equals y.",00:50:51.190,00:50:57.700
Getting my letters mixed up.,00:50:57.700,00:51:00.310
"As long as a does
not equal y, then",00:51:00.310,00:51:02.230
"we can use the point a
comma j, that must be,",00:51:02.230,00:51:05.512
"these are always
in your execution,",00:51:05.512,00:51:06.970
"and if a does not equal y, then
we're, that's a third point",00:51:06.970,00:51:10.420
and we're done.,00:51:10.420,00:51:13.130
"So we're left with one more
case, which is that at time i,",00:51:13.130,00:51:17.454
"a is here, here's a, and
at time j, a is here.",00:51:17.454,00:51:25.450
"Question is, what
happened in between?",00:51:25.450,00:51:28.720
a changed.,00:51:28.720,00:51:29.510
"For a to change, something
in here has to get rotated.",00:51:32.130,00:51:37.560
"That's the [? clam. ?] I mean
here's the picture, you have a,",00:51:37.560,00:51:40.950
"actually-- picture is
at the beginning a is x.",00:51:40.950,00:51:46.890
"So, here we have x, and then
y is an ancestor, sorry,",00:51:46.890,00:51:51.960
"y is a descendant of
x, because this is a.",00:51:51.960,00:51:55.320
"And then somehow we
have to transition",00:51:55.320,00:51:57.150
"to the reverse picture,
which is that y is",00:51:57.150,00:51:59.190
"the least common ancestor, x.",00:51:59.190,00:52:03.550
"And for this to happen, somebody
here has to get rotated.",00:52:03.550,00:52:08.460
"I guess, in particular x.",00:52:08.460,00:52:10.500
"At some point x had to
overtake y, had to be moved up.",00:52:10.500,00:52:16.120
"So, at some point x was
rotated, and that would",00:52:16.120,00:52:19.170
correspond to a point here.,00:52:19.170,00:52:20.340
"So else x must be
rotated at some time",00:52:23.030,00:52:32.310
"k, where k is between i and j.",00:52:32.310,00:52:37.110
"And if we set it up right, I
guess because here a was still",00:52:47.710,00:52:51.420
"x, and here a is y, then it
must be strictly between.",00:52:51.420,00:53:00.340
"Maybe like this would
be what we want.",00:53:03.700,00:53:06.250
"And so then we use
the point k comma x.",00:53:09.110,00:53:13.620
Is that more or less clear?,00:53:19.886,00:53:21.050
This was the easy case.,00:53:24.522,00:53:25.480
"I guess it depends
what you consider easy.",00:53:28.570,00:53:30.790
"Here we're just, we're
given a search tree",00:53:30.790,00:53:33.980
"and the short version is, look
at the least common ancestor.",00:53:33.980,00:53:38.810
"It's got to move around at
some point, or not, either way",00:53:38.810,00:53:42.460
you're happy.,00:53:42.460,00:53:44.450
"So the least common
ancestor gives you",00:53:44.450,00:53:46.420
the points you care about.,00:53:46.420,00:53:48.650
"So for that we just needed the
least common ancestor idea.",00:53:48.650,00:53:51.820
"For the other
direction, if we're",00:53:51.820,00:53:53.470
"given a point set
that corresponds",00:53:53.470,00:53:55.270
"to, that has this
satisfaction property,",00:53:55.270,00:53:58.510
"we have to somehow build from
scratch a binary search tree.",00:53:58.510,00:54:02.207
"How the heck are we going to
build a binary search tree?",00:54:02.207,00:54:04.540
"Well, with treaps.",00:54:04.540,00:54:08.845
"So, this is the other direction.",00:54:37.370,00:54:39.350
"Treap is a portmanteau
of tree and heap.",00:54:46.520,00:54:52.356
"Underline it
correctly, tree, heap.",00:54:52.356,00:54:56.180
"So, it's simultaneously a binary
search tree and a min heap,",00:54:56.180,00:55:01.160
in this case.,00:55:01.160,00:55:03.110
"It's a binary search tree
because it has to be.",00:55:03.110,00:55:05.200
"It's a binary search
tree on the keys.",00:55:05.200,00:55:07.790
"It's going to be heap on
a different set of values.",00:55:07.790,00:55:12.170
"So, binary search tree on
the keys, and it's heap",00:55:12.170,00:55:22.400
"ordered, min heap
ordered, by next access.",00:55:22.400,00:55:32.420
"I didn't say I was going to
give you an online algorithm,",00:55:35.625,00:55:38.000
this is an offline algorithm.,00:55:38.000,00:55:40.280
"So it looks-- if
I look at a key,",00:55:40.280,00:55:44.060
"and it's going to be accessed
next, it better be at the root.",00:55:44.060,00:55:48.350
"Next access will
always be at the root,",00:55:48.350,00:55:50.730
if you're heap ordered.,00:55:50.730,00:55:51.730
"If you're a min
heap by next access.",00:55:51.730,00:55:54.050
"This is great, that
means the thing you're",00:55:54.050,00:55:56.150
"searching for is
always at the root,",00:55:56.150,00:55:57.650
"and it's basically
free to touch.",00:55:57.650,00:56:00.860
"But you may choose
to touch other nodes.",00:56:00.860,00:56:03.295
"And in fact, we're told
how to touch notes.",00:56:03.295,00:56:05.870
"We're given a pattern
that says, well,",00:56:05.870,00:56:07.550
"at this time you have-- you
will touch this node, this node,",00:56:07.550,00:56:10.820
and this node.,00:56:10.820,00:56:12.650
"By that definition, this
one will be at the root,",00:56:12.650,00:56:16.437
"but you're going to
touch these nodes,",00:56:16.437,00:56:18.020
"and possibly you
could rotate them.",00:56:18.020,00:56:20.750
Change the tree.,00:56:20.750,00:56:22.460
"You'll have to, actually,
because next access",00:56:22.460,00:56:24.650
time is constantly changing.,00:56:24.650,00:56:26.510
"And as soon as you
access an item,",00:56:26.510,00:56:28.490
"it's next access goes in
sometime in the future,",00:56:28.490,00:56:31.040
"possibly infinity, and so you'd
like to start pushing it down",00:56:31.040,00:56:34.010
in the tree.,00:56:34.010,00:56:34.510
"So, what we need to
do is show that we",00:56:37.420,00:56:39.420
"can maintain-- it's always going
to be a binary search tree,",00:56:39.420,00:56:41.920
because we only do rotations.,00:56:41.920,00:56:43.600
"We have to somehow use rotations
to maintain this heap order",00:56:43.600,00:56:46.480
"property, and only touch
the nodes that we're",00:56:46.480,00:56:52.240
supposed to touch.,00:56:52.240,00:56:53.920
That's the challenge.,00:56:53.920,00:56:57.380
"So, I should mention, this is
not a uniquely defined tree.",00:56:57.380,00:57:02.350
"Usually treaps are unique,
if you specify a key order,",00:57:02.350,00:57:05.440
"and you specify a
heap order, there",00:57:05.440,00:57:06.980
"is exactly one tree that
satisfies both of them.",00:57:06.980,00:57:10.840
"But here it's not quite
unique, because the next access",00:57:10.840,00:57:13.720
"time-- there are many keys that
are going, sorry, next touch.",00:57:13.720,00:57:17.210
Next touch time.,00:57:20.770,00:57:23.020
"So, for example, at this
moment all three of these nodes",00:57:23.020,00:57:29.410
"are going to be accessed
at the same time.",00:57:29.410,00:57:32.610
"And so you don't
know, or I'm not",00:57:32.610,00:57:34.975
"specifying how they're supposed
to be heap ordered in the tree.",00:57:34.975,00:57:37.600
"Just break ties arbitrarily,
it doesn't matter.",00:57:37.600,00:57:41.270
OK.,00:57:41.270,00:57:43.450
"So, let's look at a time i.",00:57:43.450,00:57:53.800
"When we reach that
time i, the nodes",00:57:53.800,00:57:57.670
"to touch form and connected
subtree containing the root.",00:57:57.670,00:58:10.266
"Because according to
heap order, they're all,",00:58:13.620,00:58:15.820
they all want to be at the root.,00:58:15.820,00:58:17.530
"So we break ties arbitrarily,
somehow, you know all the nodes",00:58:17.530,00:58:23.440
"that we're supposed to touch,
live in some connected subtree",00:58:23.440,00:58:27.280
of the root.,00:58:27.280,00:58:30.300
"Sorry, some connected
subtree containing the root.",00:58:30.300,00:58:34.870
"Everything down here has
a later next touch time,",00:58:34.870,00:58:40.420
"and so they're below, by
definition of heap order.",00:58:40.420,00:58:45.060
"OK, now one of these is the
one we actually want to access.",00:58:45.060,00:58:47.729
"But we need to touch all of
them, so touch all of them,",00:58:47.729,00:58:50.020
"you know, navigate.",00:58:50.020,00:58:50.811
"Walk left, right, whatever.",00:58:50.811,00:58:52.420
"The big question is, what
should we change this tree into?",00:58:52.420,00:58:55.360
"I'd like to change it to
some other top structure.",00:58:55.360,00:59:01.930
"I can't touch
anything down here,",00:59:01.930,00:59:03.520
"I'm only allowed to
touch these points.",00:59:03.520,00:59:05.790
"I only want to
rotate these somehow.",00:59:05.790,00:59:09.507
"There's a convenient
theorem, if you have one tree",00:59:09.507,00:59:11.590
"and you want to convert
it into another,",00:59:11.590,00:59:13.256
"you can always do it in a
linear number of rotations.",00:59:13.256,00:59:15.970
"So, rotations are basically
free and this model,",00:59:15.970,00:59:18.130
"it's just about how
many nodes we touch.",00:59:18.130,00:59:20.650
We're told which nodes to touch.,00:59:20.650,00:59:22.270
"We want to somehow rearrange
them to restore this heap order",00:59:22.270,00:59:25.120
property.,00:59:25.120,00:59:26.030
Right?,00:59:26.030,00:59:26.530
"As soon as we touch
all these nodes,",00:59:26.530,00:59:28.090
"their next touch time will
be sometime in the future.",00:59:28.090,00:59:31.810
"We need to rearrange the
tree to still be heap ordered",00:59:31.810,00:59:34.700
by that new next touch time.,00:59:34.700,00:59:37.000
"OK, here's what we do.",00:59:39.600,00:59:42.250
"I mean there's only
one thing to do.",00:59:45.731,00:59:47.230
"Rearrange those nodes in
this connected subtree",00:59:49.870,00:59:54.610
"to be a local treap by
the new next touch time.",00:59:54.610,01:00:04.240
"These are the only nodes to
get a new next touch time,",01:00:04.240,01:00:11.680
"so it's more or less unique
how to rearrange them.",01:00:11.680,01:00:15.970
Do that.,01:00:15.970,01:00:17.260
"Now the hard part is to argue
that the whole thing is now",01:00:17.260,01:00:20.430
a treap.,01:00:20.430,01:00:20.930
"Why was it enough to
only modify these nodes?",01:00:24.140,01:00:29.210
"Maybe you set one of these nodes
to have a very large next touch",01:00:29.210,01:00:32.510
"time, so it's got to be
really deep down there.",01:00:32.510,01:00:35.199
"And you can't afford to push it
down deep, because you're not",01:00:35.199,01:00:37.740
"allowed to touch
any of these nodes.",01:00:37.740,01:00:40.200
"Looks worrisome, but
turns out, it just works.",01:00:40.200,01:00:44.370
"So, if there were a failure,
picture would be like this.",01:00:47.390,01:00:55.350
"We rearrange these nodes
perfectly, in particular,",01:00:55.350,01:00:59.290
"let's look at some
node x that has a child",01:00:59.290,01:01:01.720
"y, that was not touched.",01:01:01.720,01:01:03.900
"So x was touched, all of
it's ancestors were touched,",01:01:03.900,01:01:06.690
but y was not touched.,01:01:06.690,01:01:09.390
"So we know that the
next touch time of x",01:01:09.390,01:01:12.867
"is greater than or equal to the
next touch time of its parent,",01:01:12.867,01:01:15.450
"of it's ancestor,
up to the root.",01:01:15.450,01:01:17.730
"The worry would be that
the next touch time of x",01:01:17.730,01:01:20.850
"is greater than the
next touch time of y.",01:01:20.850,01:01:23.720
"So suppose next touch of x is
greater than next touch of y.",01:01:23.720,01:01:38.802
"This would be a problem, because
then you would not be a heap.",01:01:38.802,01:01:41.385
"So, claim is we get an
unsatisfied rectangle",01:01:46.000,01:02:17.850
"based on x and it's next touch
time, and y and it's next touch",01:02:17.850,01:02:20.940
time.,01:02:20.940,01:02:21.720
So let's draw the picture.,01:02:21.720,01:02:24.030
"Here's time, here's
space, I'm going",01:02:24.030,01:02:30.540
"to assume by symmetry x
is to the left of y and",01:02:30.540,01:02:34.950
"[? keyspace, ?] and
now we're supposing",01:02:34.950,01:02:38.970
"the next touch time of y is
earlier than the next touch",01:02:38.970,01:02:42.375
time of x.,01:02:42.375,01:02:43.050
So it looks like this.,01:02:43.050,01:02:45.820
"So this is next touch time of
x, this is the next time of y,",01:02:45.820,01:02:53.730
"and I claim that there are
no other points in here.",01:02:53.730,01:03:00.041
"That would be a contradiction,
because we assume",01:03:00.041,01:03:02.040
that the thing is satisfied.,01:03:02.040,01:03:03.240
"To prove this, I need to go back
a little bit to the definition,",01:03:10.650,01:03:16.350
over here.,01:03:16.350,01:03:16.890
"There are actually a
couple of different ways",01:03:20.955,01:03:22.830
"to think about satisfaction,
which I was getting at here,",01:03:22.830,01:03:26.550
but I didn't solidify.,01:03:26.550,01:03:28.140
"So, I said OK, if
you have two points",01:03:28.140,01:03:29.820
"and that rectangle
is satisfied, there",01:03:29.820,01:03:31.690
"is some point, possibly in the
interior, in that rectangle.",01:03:31.690,01:03:35.980
"But if it's interior,
then I can keep going.",01:03:35.980,01:03:39.870
"If I keep going, in the end I
can conclude that not only is",01:03:39.870,01:03:45.840
"this rectangle
non-empty, but there",01:03:45.840,01:03:47.730
"has to be a point on
one of these two sides,",01:03:47.730,01:03:52.880
"because if I choose
any other point,",01:03:52.880,01:03:54.867
I get a smaller rectangle.,01:03:54.867,01:03:55.950
"Eventually, I have to get one
on one of those two sides.",01:03:55.950,01:03:58.860
"Could be at the
corner, or this corner,",01:03:58.860,01:04:01.242
"but one of those two sides
has to have a point on it.",01:04:01.242,01:04:03.450
"Also, one of these two sides
has to have a point on it.",01:04:03.450,01:04:06.789
"It could be both of
these constraints",01:04:06.789,01:04:08.330
"are met at once by having
one point in the corner.",01:04:08.330,01:04:12.300
"Well that's a somewhat stronger
formulation, but equivalent",01:04:12.300,01:04:14.760
"formulation of the
satisfaction property.",01:04:14.760,01:04:18.120
"So in particular over
here, it should be the case",01:04:18.120,01:04:23.160
"that there's a point,
either here or here,",01:04:23.160,01:04:26.100
"and there should be a
point, either here or here.",01:04:26.100,01:04:28.410
"I claim that one of
those is violated.",01:04:28.410,01:04:30.360
"You think I'd know this stuff,
I wrote the paper, but--",01:04:45.649,01:04:47.940
"it's all these subtle
details, easy to get wrong.",01:04:50.640,01:04:54.090
"I think what I want
to look at is, now,",01:04:54.090,01:05:00.040
"which is the moment we're
drawing this diagram, versus",01:05:00.040,01:05:03.580
the next time of y.,01:05:03.580,01:05:06.010
"Sorry, so this is x comma now.",01:05:06.010,01:05:09.100
"That's what my diagram
looks like there,",01:05:11.354,01:05:13.020
so I think that's what I mean.,01:05:13.020,01:05:15.070
So ignore this picture.,01:05:15.070,01:05:16.150
"What we learn, what we know
is the next access to x,",01:05:20.190,01:05:23.830
is sometime in the future.,01:05:23.830,01:05:25.194
That's what we're told here.,01:05:25.194,01:05:26.360
"Next touch of x is greater
than next touch of y.",01:05:26.360,01:05:30.460
"So next touch of x is up here,
which means this is empty.",01:05:30.460,01:05:35.580
"OK, if that's empty,
this better not be empty.",01:05:35.580,01:05:40.011
"All right that's what we
claim, one of these two",01:05:40.011,01:05:42.010
has to have a point in it.,01:05:42.010,01:05:44.830
"This one's empty, so
this better not be empty,",01:05:44.830,01:05:47.440
but I claim this is empty.,01:05:47.440,01:05:48.670
"Suppose it's not, suppose it
is, suppose it's not empty--",01:05:48.670,01:05:53.401
"Wait, no, one of these.",01:05:53.401,01:05:56.460
"Suppose it's not empty, should
be the correct scenario.",01:05:56.460,01:06:00.850
"Look at the left most
point in this range.",01:06:00.850,01:06:03.460
This guy.,01:06:09.960,01:06:10.725
"It's a point between x and
y, in terms of key value.",01:06:15.620,01:06:19.620
"So, in this picture,
where could it be?",01:06:19.620,01:06:23.870
"Where are the points between
x and y in this diagram?",01:06:23.870,01:06:29.470
"They have to be in
the left subtree of y.",01:06:29.470,01:06:31.861
Right?,01:06:31.861,01:06:32.360
"The only points in a binary
search-- if x and y are--",01:06:32.360,01:06:34.827
"if y is a child of x, the
only points in the binary tree",01:06:34.827,01:06:37.160
"that are between x and y,
or the left subtree of y,",01:06:37.160,01:06:40.640
"or there's a symmetric case,
but in this picture left subtree",01:06:40.640,01:06:43.400
of y.,01:06:43.400,01:06:44.870
But I put an x here.,01:06:44.870,01:06:45.970
"That means that whoever
we're looking at,",01:06:45.970,01:06:48.500
"some point between x and y,
has to be in this top tree.",01:06:48.500,01:06:52.760
"Contradiction, done, OK?",01:06:52.760,01:06:55.310
"If this guy is in there,
then y was also in there,",01:06:55.310,01:06:58.130
"which meant there
was a point here,",01:06:58.130,01:07:01.554
"and that's what we're
assuming did not happen.",01:07:01.554,01:07:03.470
"This is supposed
to be an interface",01:07:03.470,01:07:04.928
"between inside the
set of touched nodes,",01:07:04.928,01:07:07.550
"and outside the set
of touched nodes.",01:07:07.550,01:07:10.740
"So there can't be
any points in here,",01:07:10.740,01:07:14.090
"which means this is empty, which
means you weren't satisfied.",01:07:14.090,01:07:17.686
"OK, maybe I should
write down the words",01:07:17.686,01:07:19.310
"to go with that argument, but--",01:07:19.310,01:07:21.110
"So, this part is empty by
next touch of x being greater",01:07:25.680,01:07:34.770
than next touch of y.,01:07:34.770,01:07:37.530
"And this part is empty
else, or it's empty",01:07:37.530,01:07:45.180
"because any key
between x and y is",01:07:45.180,01:08:03.960
"in the left subtree of
y, which would imply",01:08:03.960,01:08:18.189
if it's touched then so is y.,01:08:18.189,01:08:28.930
"But y cannot be
touched, by assumption.",01:08:28.930,01:08:32.450
So that's the end of that proof.,01:08:32.450,01:08:34.960
"A little bit longer,
but hopefully",01:08:34.960,01:08:38.137
it's pretty clear at this point.,01:08:38.137,01:08:39.470
Question?,01:08:39.470,01:08:40.778
"AUDIENCE: Can't
there be something",01:08:40.778,01:08:43.148
"like a descendent of x,
but an ancestor of y,",01:08:43.148,01:08:45.810
"instead of being in
a subtree with y?",01:08:45.810,01:08:49.034
"PROFESSOR: Would,
so you could say",01:08:49.034,01:08:50.450
it could be in between here.,01:08:50.450,01:08:51.884
"It could be a descendant
of x, but an ancestor of y,",01:08:51.884,01:08:54.050
"but we're assuming here that
this was a child relation.",01:08:54.050,01:08:56.810
y was a child of x.,01:08:56.810,01:08:58.310
This was a--,01:08:58.310,01:08:59.394
"I didn't say that
at the beginning.",01:08:59.394,01:09:01.536
"On a claim that's a
global treap, if it's not",01:09:01.536,01:09:03.410
"a global treap, there is
some edge that's violated,",01:09:03.410,01:09:06.710
"that does not have
heap order property.",01:09:06.710,01:09:08.340
"So assuming this was
an edge, x is OK,",01:09:08.340,01:09:11.180
"it was in the local
treap, y somehow",01:09:11.180,01:09:13.609
"is going to be bad, because
it's next touch time was,",01:09:13.609,01:09:16.100
should be higher.,01:09:16.100,01:09:16.970
Should be above.,01:09:16.970,01:09:18.050
Other question?,01:09:18.050,01:09:19.008
"AUDIENCE: So that
[INAUDIBLE] you drew,",01:09:19.008,01:09:21.000
"and all the everything in that
subtree root that gets taken",01:09:21.000,01:09:25.980
to--,01:09:25.980,01:09:26.976
"Like the picture on
the right is also,",01:09:26.976,01:09:28.968
it's the same subtree right?,01:09:28.968,01:09:30.462
"But after you change
their [INAUDIBLE]",01:09:30.462,01:09:32.479
"PROFESSOR: These two subtrees
have the same set of nodes,",01:09:32.479,01:09:34.340
"they've just been
rotated somehow.",01:09:34.340,01:09:35.756
"AUDIENCE: OK, but then
how do you-- but didn't",01:09:35.756,01:09:38.926
"we change the next touch times
of all the nodes in there?",01:09:38.926,01:09:41.524
"So how you do know if
the root is still going",01:09:41.524,01:09:43.472
to be some guy in that subtree?,01:09:43.472,01:09:45.420
PROFESSOR: Buy this argument.,01:09:48.850,01:09:50.189
"So the question is
say, after we do this,",01:09:50.189,01:09:53.340
"we make some root,
which is going,",01:09:53.340,01:09:55.860
"the root is going to
be among all the nodes",01:09:55.860,01:09:58.110
"that just got touched now, who
is going to be touched next?",01:09:58.110,01:10:02.280
That's who we put at the root.,01:10:02.280,01:10:03.720
"And the claim is, that
is globally the node that",01:10:03.720,01:10:07.050
will be touched next.,01:10:07.050,01:10:08.100
Why?,01:10:08.100,01:10:08.800
By this argument.,01:10:08.800,01:10:11.220
"If there were some other node
down here that has a smaller",01:10:11.220,01:10:15.360
"next access time, then--",01:10:15.360,01:10:18.655
"but we know that it was
heap ordered before,",01:10:22.947,01:10:24.780
"so all of these guys
are heap ordered.",01:10:24.780,01:10:26.500
"So, this guy would
then have the minimum.",01:10:26.500,01:10:28.680
"And then we look
at that interface,",01:10:28.680,01:10:30.150
"and the claim is by the
satisfaction property,",01:10:30.150,01:10:32.900
"actually this point should
have been in the set.",01:10:32.900,01:10:35.306
"So, what this tells
you is the guy that",01:10:35.306,01:10:36.930
"has to be accessed
next, in particular,",01:10:36.930,01:10:38.970
must be in your set.,01:10:38.970,01:10:41.340
Must be touched now.,01:10:41.340,01:10:42.819
Kind of magical.,01:10:46.950,01:10:48.810
"Well actually, it's because
they're tie-breaking",01:10:48.810,01:10:51.180
"I think, that this works out.",01:10:51.180,01:10:53.690
"Anyway, another question?",01:10:53.690,01:10:55.454
"AUDIENCE: So, like when you're
rearranging the [INAUDIBLE]",01:10:55.454,01:10:59.406
"in the sort of subtree
on top [INAUDIBLE]",01:10:59.406,01:11:04.800
"PROFESSOR: Yeah, we're
doing this transformation",01:11:04.800,01:11:06.800
"of the top tree into the
local tree by rotations.",01:11:06.800,01:11:09.389
I mentioned--,01:11:09.389,01:11:09.930
"AUDIENCE: [INAUDIBLE]
It's always--",01:11:09.930,01:11:12.674
"PROFESSOR: Right,
so we're staying",01:11:12.674,01:11:14.090
"within the binary search tree
model, and in particular then",01:11:14.090,01:11:16.548
we stay a binary search tree.,01:11:16.548,01:11:18.054
"So, we can't mess things up.",01:11:18.054,01:11:19.220
"And there's a nice theorem that
if you have two binary search",01:11:19.220,01:11:21.260
"trees on the same,
keys there's a way",01:11:21.260,01:11:23.000
"to get there with the
linear number of rotates,",01:11:23.000,01:11:25.280
so that's for free.,01:11:25.280,01:11:28.130
"So, our new cost model
is just to count points.",01:11:28.130,01:11:31.790
"The cost of this access is
one, the cost of this access",01:11:31.790,01:11:34.580
"is two, two, three.",01:11:34.580,01:11:37.070
"If we just count how
many nodes are touched,",01:11:37.070,01:11:40.370
"then the cost of the
binary search tree",01:11:40.370,01:11:43.550
"is equal to the cost of
the minimum satisfied",01:11:43.550,01:11:48.830
superset of your point.,01:11:48.830,01:11:50.270
So this is the problem now.,01:11:50.270,01:11:52.760
"Sadly we don't know how
to solve the problem.",01:11:52.760,01:11:56.390
We do know some things.,01:11:56.390,01:12:01.080
"I don't think I'll go
through an example of this,",01:12:01.080,01:12:03.822
it's not very exciting.,01:12:03.822,01:12:04.780
"You could run
through this picture,",01:12:04.780,01:12:08.180
"and see how the binary
[? structure ?] changes.",01:12:08.180,01:12:10.250
"Actually the binary
[? structure ?]",01:12:10.250,01:12:11.708
"won't change it all here, so
it's a little anticlimactic",01:12:11.708,01:12:14.360
of an example.,01:12:14.360,01:12:15.030
You can see it in the notes.,01:12:15.030,01:12:18.200
"I want to get to the greedy
algorithm, so let's go here.",01:12:18.200,01:12:25.540
Last bullet.,01:12:34.850,01:12:35.898
"The idea is to imagine
your points are added one",01:13:14.860,01:13:18.540
"at a time, bottom up.",01:13:18.540,01:13:20.700
"So I'm going to do
the same example.",01:13:24.060,01:13:25.680
First we add this point.,01:13:25.680,01:13:27.780
"That's a satisfied set, done.",01:13:27.780,01:13:29.730
"In general add necessary points
on the same row as the search.",01:13:29.730,01:13:50.230
"OK, there's nothing to add here.",01:13:50.230,01:13:51.760
Next point we add is over here.,01:13:51.760,01:13:53.910
"I've got the orientation
correct, yeah.",01:13:53.910,01:13:56.170
"So this was three, this was one.",01:13:56.170,01:13:59.060
Is this satisfied?,01:13:59.060,01:14:00.340
"No, there's a bad
rectangle here.",01:14:00.340,01:14:02.937
"There's two obvious ways
to satisfy the rectangle,",01:14:02.937,01:14:05.020
"I could add a point here,
or I could add a point here.",01:14:05.020,01:14:07.550
"I'm going to add a point
here, because that's the row,",01:14:07.550,01:14:09.800
this is current time.,01:14:09.800,01:14:10.720
"OK, it's like a
sweep line algorithm.",01:14:10.720,01:14:14.050
"We go up, next
point is over here.",01:14:14.050,01:14:18.721
"That's the Next
position to sweep line.",01:14:18.721,01:14:20.890
Now there's a bad rectangle.,01:14:20.890,01:14:22.840
We fix it by adding this point.,01:14:22.840,01:14:24.420
"Now we're good, all
rectangles are satisfied.",01:14:27.010,01:14:29.950
"Next level is,
there's a point here.",01:14:29.950,01:14:33.490
Now there's two bad rectangles.,01:14:33.490,01:14:35.440
"This one, I'm going
to add a point here,",01:14:35.440,01:14:38.170
"and this one, I'm going
to add a point here.",01:14:38.170,01:14:40.976
Now we're good.,01:14:44.640,01:14:46.620
"And that should be
what I did here.",01:14:46.620,01:14:49.740
Yeah.,01:14:49.740,01:14:50.240
"So that's how I
found that point set,",01:14:52.619,01:14:54.160
"and in general claim is
this is a good algorithm.",01:14:54.160,01:14:57.540
"It seems, in fact,
pretty obvious.",01:14:57.540,01:15:01.320
"There was a choice of
course, we could satisfy",01:15:01.320,01:15:04.260
this corner or this corner.,01:15:04.260,01:15:05.940
"Or some monotone
path in between.",01:15:05.940,01:15:09.330
But the claim would be that--,01:15:09.330,01:15:11.010
"doesn't make that
big a difference.",01:15:15.510,01:15:17.460
"Doing things later
is always better.",01:15:17.460,01:15:18.970
It's kind of a lazy property.,01:15:18.970,01:15:20.550
Or you could think of this--,01:15:20.550,01:15:22.614
"Originally actually
this algorithm",01:15:22.614,01:15:24.030
goes back in tree land.,01:15:24.030,01:15:26.160
"And in tree land, if you follow
through this reduction, which",01:15:26.160,01:15:29.041
"we did, you know
if you convert this",01:15:29.041,01:15:30.540
"into a treap, what
this is saying is,",01:15:30.540,01:15:33.750
"look you search for an
item, you follow a path.",01:15:33.750,01:15:36.510
"Take all the nodes on
the path that you follow,",01:15:36.510,01:15:39.150
"rearrange them optimally
for the future,",01:15:39.150,01:15:41.700
"build a heap based on the next
access time, next touch time,",01:15:41.700,01:15:45.690
whenever that happens to be.,01:15:45.690,01:15:48.270
"Next access time
actually, in that case.",01:15:48.270,01:15:51.060
"That is equivalent
to this algorithm.",01:15:51.060,01:15:55.200
"That seems like the right
thing to do offline.",01:15:55.200,01:15:57.457
"You visit your item, you do the
minimum amount you have to do,",01:15:57.457,01:16:00.040
"which is following
the search path.",01:16:00.040,01:16:01.680
"You rearrange those items to
be optimal for the future.",01:16:01.680,01:16:04.590
"It's an offline algorithm,
seems like a really good one.",01:16:04.590,01:16:07.020
"The only thing
it's missing out on",01:16:07.020,01:16:08.610
"is maybe you should
go off the path",01:16:08.610,01:16:10.920
"and bring other guys
closer to the root.",01:16:10.920,01:16:13.962
"But if you believe, which
we don't know how to prove,",01:16:13.962,01:16:16.170
if you believe that there's no--,01:16:16.170,01:16:17.503
"it doesn't really
buy you anything",01:16:17.503,01:16:19.140
"to go off the path now,
you can always do it later,",01:16:19.140,01:16:22.290
"then this algorithm
is optimal offline.",01:16:22.290,01:16:26.500
"And in terms of the
point set it's--",01:16:26.500,01:16:28.000
"in the point set of
view it's kind of nice",01:16:28.000,01:16:29.749
"because it almost
looks online, right.",01:16:29.749,01:16:31.360
"You only have to
look at each time",01:16:31.360,01:16:33.510
"and add the points at
that time that are useful,",01:16:33.510,01:16:37.080
in terms of the past.,01:16:37.080,01:16:38.490
"You only had to satisfy
the rectangles of the past.",01:16:38.490,01:16:41.444
"So this is where
things get interesting,",01:16:41.444,01:16:43.110
"because in terms of a tree
view, with this transformation,",01:16:43.110,01:16:46.100
"this looks like an
offline tree because it",01:16:46.100,01:16:48.810
needs to know the future.,01:16:48.810,01:16:49.890
"And it does if you
want to build a heap.",01:16:49.890,01:16:52.270
"OK, but if you look
at in the geometric",01:16:52.270,01:16:54.360
"view, suddenly it looks
online, because you're only",01:16:54.360,01:16:56.640
"looking at the points
and all the points",01:16:56.640,01:16:58.306
you've accessed in the past.,01:16:58.306,01:16:59.940
"So, in fact, there's a
way to make this online.",01:16:59.940,01:17:04.050
"This is where things
get interesting.",01:17:08.550,01:17:11.329
"There is a transformation
that if you",01:17:11.329,01:17:12.870
"have an online satisfying
point set, meaning you",01:17:12.870,01:17:17.100
"can decide what points to
add based only on the past,",01:17:17.100,01:17:19.410
not on the future.,01:17:19.410,01:17:21.480
"So it's a fancier version
of this transformation,",01:17:21.480,01:17:23.770
"you get an actual online
binary search tree.",01:17:23.770,01:17:27.460
"So, this algorithm goes
back to the '90s I think.",01:17:27.460,01:17:33.510
"Actually '88, it's in a
thesis 1988 as rediscovered",01:17:33.510,01:17:37.440
by my PhD adviser in 2000.,01:17:37.440,01:17:42.630
"It's totally natural
algorithm, but they thought",01:17:42.630,01:17:45.754
it was an offline algorithm.,01:17:45.754,01:17:46.920
"With this view, it's
an online algorithm.",01:17:46.920,01:17:49.260
"Let me quickly convince
you, or sketch to you,",01:17:49.260,01:17:51.930
how we make this online.,01:17:51.930,01:17:54.450
"So we do the same thing, except
we don't know how to heapify,",01:17:54.450,01:18:01.647
"because we don't know
the next access times.",01:18:01.647,01:18:03.480
"But we know whatever
we touch, it's",01:18:03.480,01:18:05.025
"some connected
subtree of the root.",01:18:05.025,01:18:06.990
We know what we touch.,01:18:06.990,01:18:08.040
"We touch whatever greedy
tells us to touch.",01:18:08.040,01:18:10.230
"We'll touch all
these guys, whatever.",01:18:10.230,01:18:12.699
How do we rearrange them?,01:18:12.699,01:18:13.740
We don't rearrange them.,01:18:13.740,01:18:15.090
"We store them into something
called a split tree.",01:18:15.090,01:18:18.300
"Split tree has the
feature, it's a tree.",01:18:21.090,01:18:23.340
"Binary search tree, and if
you ask for some item x,",01:18:23.340,01:18:27.930
you can move x to the root.,01:18:27.930,01:18:31.230
"So then you have a
left subtree of x,",01:18:31.230,01:18:33.750
"right subtree of x,
and then delete x,",01:18:33.750,01:18:37.410
"and now you're left with
things that are less than x,",01:18:37.410,01:18:40.260
"and things that
are greater than x.",01:18:40.260,01:18:42.170
Things are greater than x.,01:18:42.170,01:18:44.550
"And you can do all this
in constant amortize time.",01:18:44.550,01:18:47.280
"This is what we need,
if you think about here.",01:18:51.030,01:18:53.610
"I'm going to take all these
items that were touched,",01:18:53.610,01:18:56.460
throw them into a split tree.,01:18:56.460,01:18:59.280
"My resulting structure will
be a tree of split trees.",01:18:59.280,01:19:02.430
"So think of it as, when
I touch all these items",01:19:02.430,01:19:05.450
"I just sort of throw
them all in the root,",01:19:05.450,01:19:07.200
"but that root is
represented by a split tree.",01:19:07.200,01:19:09.540
"And then hanging off here, there
are other split trees which",01:19:09.540,01:19:12.180
may have several keys in them.,01:19:12.180,01:19:16.290
"When I do, when I
now touch a node,",01:19:16.290,01:19:19.350
"you can show that if I'm
trying to touch some node here,",01:19:19.350,01:19:22.170
"I can't just magically
touch a node here.",01:19:22.170,01:19:23.880
"I've got to, I had
to have followed",01:19:23.880,01:19:25.670
"in the actual tree, whatever
the optimal tree is,",01:19:25.670,01:19:28.170
"I had to follow some
route to leave path.",01:19:28.170,01:19:30.722
"So in fact, the
predecessor and successor",01:19:30.722,01:19:32.430
"here had to have been touched
before I touched this one.",01:19:32.430,01:19:36.390
"Which means I'm going
to split those nodes.",01:19:36.390,01:19:40.280
"So, when I actually-- this
is basically lazy evaluation.",01:19:40.280,01:19:44.200
"When I actually access
something in here,",01:19:44.200,01:19:46.780
"that means I want to
pull it to the root.",01:19:46.780,01:19:48.550
"I wanted to pretend that
it was at the root, that's",01:19:48.550,01:19:51.520
what the treap would have done.,01:19:51.520,01:19:53.860
"So basically pull it
up, be a root, split,",01:19:53.860,01:19:56.620
"because now there's
two structures left",01:19:56.620,01:19:59.020
"where I don't know
their orders, but I",01:19:59.020,01:20:00.850
know that this item was first.,01:20:00.850,01:20:03.880
And so I end up with--,01:20:03.880,01:20:05.269
"I don't actually remove
it, but I remove it",01:20:05.269,01:20:07.060
"from the split trees, so
I make it look like this.",01:20:07.060,01:20:11.570
"And here's the guy where I
wanted to access something.",01:20:11.570,01:20:14.790
"So, I split this root
into two split trees,",01:20:14.790,01:20:17.250
"and I have an
individual node up here.",01:20:17.250,01:20:19.900
"If I can do this in
constant amortize time,",01:20:19.900,01:20:21.730
"it's as if this node was at
the root in the first place.",01:20:21.730,01:20:24.140
"And so I simulate this
perfect treap order,",01:20:24.140,01:20:26.970
"but using a data
structure, split trees,",01:20:26.970,01:20:29.530
which can actually be solved.,01:20:29.530,01:20:31.622
How do you solve split trees?,01:20:31.622,01:20:32.830
"You just do the obvious
thing, more or less.",01:20:32.830,01:20:37.110
"Ideas, you know red
black trees, take",01:20:37.110,01:20:39.610
"your favorite balanced
binary search tree,",01:20:39.610,01:20:41.470
red black trees work fine.,01:20:41.470,01:20:45.620
"If you're given a node,
you can split there.",01:20:45.620,01:20:48.160
"You basically just
carve it in half.",01:20:48.160,01:20:51.670
How much does it cost to split?,01:20:51.670,01:20:53.170
"Well if you're a
little bit clever,",01:20:53.170,01:20:55.210
"let me go to a
board of cleverness.",01:20:55.210,01:20:57.887
"The one thing we
have to optimize for",01:21:00.259,01:21:01.800
"is, what if you're
splitting like right",01:21:01.800,01:21:03.425
"here, very close to the left?",01:21:03.425,01:21:05.760
"If you're clever,
you'll search from here,",01:21:05.760,01:21:08.580
"and cut off this part in
time basically proportional",01:21:08.580,01:21:11.040
to the height of that tree.,01:21:11.040,01:21:13.190
"OK, you might get some
propagation up here,",01:21:13.190,01:21:15.180
but that's very small amortized.,01:21:15.180,01:21:17.722
"OK, on the other hand,
if you search over here,",01:21:17.722,01:21:19.680
"you'd like to spend only
time proportional to this.",01:21:19.680,01:21:22.600
"So in general, if you just
search in parallel here,",01:21:22.600,01:21:27.060
you can split in--,01:21:27.060,01:21:29.570
"let's say this has size n one,
and the rest has size n two.",01:21:29.570,01:21:34.410
"You can split in order log
the min of n one and n two.",01:21:34.410,01:21:41.710
"And you can show that if you
just-- that's straightforward",01:21:41.710,01:21:44.220
"splitting, that's
really easy to do.",01:21:44.220,01:21:46.210
"You can show that that
implies constant amortized,",01:21:46.210,01:21:48.930
"because either you're cutting
off a very little nibble",01:21:48.930,01:21:51.330
"and the cost is small,
or you're cutting things",01:21:51.330,01:21:53.310
"more or less in half, but
that can't happen very much.",01:21:53.310,01:21:55.650
"Then you charge to the fact
that log n is going down by one,",01:21:55.650,01:21:59.130
"and overall you get a linear
cost to splitting nodes.",01:21:59.130,01:22:03.400
It's an amortization.,01:22:06.070,01:22:07.134
"Now the trouble is this is
not a binary search tree.",01:22:07.134,01:22:09.300
"How in the heck do
I have to pointers",01:22:09.300,01:22:10.841
that in parallel search?,01:22:10.841,01:22:12.330
"Well you have to take these
two halves of the tree",01:22:12.330,01:22:14.880
"and interleave them to make
them a binary search tree.",01:22:14.880,01:22:17.310
"It's kind of awkward, but just
put it, mash it all together.",01:22:17.310,01:22:21.210
"Fold it in half, basically
and turn it upside down,",01:22:21.210,01:22:24.350
"and you've got a
binary search tree.",01:22:24.350,01:22:25.974
"So there's some
messy stuff there,",01:22:25.974,01:22:27.390
"but that's just a
hand-wavy argument",01:22:27.390,01:22:29.580
that you can make greedy online.,01:22:29.580,01:22:32.400
"Next class we'll talk about
lower bounds, which almost",01:22:32.400,01:22:35.280
proved the greedy is optimal.,01:22:35.280,01:22:36.630
But not quite.,01:22:36.630,01:22:38.630
