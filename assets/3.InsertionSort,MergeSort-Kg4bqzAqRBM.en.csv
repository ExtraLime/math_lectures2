text,start,stop
"The following
content is provided",00:00:00.080,00:00:01.770
"under a Creative
Commons license.",00:00:01.770,00:00:04.010
"Your support will help MIT
OpenCourseWare continue",00:00:04.010,00:00:06.860
"to offer high quality
educational resources for free.",00:00:06.860,00:00:10.720
"To make a donation or
view additional materials",00:00:10.720,00:00:13.330
"from hundreds of MIT courses,
visit MIT OpenCourseWare",00:00:13.330,00:00:17.228
at ocw.mit.edu.,00:00:17.228,00:00:17.853
"PROFESSOR: So today's
lecture is on sorting.",00:00:23.290,00:00:27.010
"We'll be talking about specific
sorting algorithms today.",00:00:27.010,00:00:31.310
"I want to start
by motivating why",00:00:31.310,00:00:34.570
"we're interested in sorting,
which should be fairly easy.",00:00:34.570,00:00:37.105
"Then I want to discuss
a particular sorting",00:00:39.690,00:00:42.490
"algorithm that's
called insertion sort.",00:00:42.490,00:00:45.470
"That's probably the
simplest sorting algorithm",00:00:45.470,00:00:47.860
"you can write, it's
five lines of code.",00:00:47.860,00:00:51.942
"It's not the best
sorting algorithm",00:00:51.942,00:00:53.400
"that's out there and so
we'll try and improve it.",00:00:53.400,00:00:57.430
"We'll also talk about merge
sort, which is a divide",00:00:57.430,00:01:00.470
"and conquer algorithm
and that's going",00:01:00.470,00:01:03.250
"to motivate the last thing
that I want to spend time on,",00:01:03.250,00:01:09.010
"which is recurrences and
how you solve recurrences.",00:01:09.010,00:01:12.300
"Typically the
recurrences that we'll",00:01:12.300,00:01:14.230
"be looking at in double o six
are going to come from divide",00:01:14.230,00:01:18.120
"and conquer problems
like merge sort",00:01:18.120,00:01:20.760
"but you'll see
this over and over.",00:01:20.760,00:01:24.300
"So let's talk about why
we're interested in sorting.",00:01:24.300,00:01:26.965
"There's some fairly
obvious applications",00:01:30.110,00:01:34.370
"like if you want to
maintain a phone book,",00:01:34.370,00:01:37.490
"you've got a bunch of names
and numbers corresponding",00:01:37.490,00:01:42.010
"to a telephone
directory and you want",00:01:42.010,00:01:44.830
"to keep them in
sorted order so it's",00:01:44.830,00:01:46.330
"easy to search, mp3 organizers,
spreadsheets, et cetera.",00:01:46.330,00:01:51.510
"So there's lots of
obvious applications.",00:01:51.510,00:01:54.590
"There's also some
interesting problems",00:01:54.590,00:01:59.630
"that become easy once
items are sorted.",00:01:59.630,00:02:05.900
"One example of that
is finding a median.",00:02:13.790,00:02:18.170
"So let's say that you
have a bunch of items",00:02:23.860,00:02:27.220
"in an array a zero through
n and a zero through n",00:02:27.220,00:02:36.210
"contains n numbers and
they're not sorted.",00:02:36.210,00:02:38.650
"When you sort, you
turn this into b 0",00:02:44.850,00:02:48.950
"through n, where if
it's just numbers, then",00:02:48.950,00:02:52.760
"you may sort them in increasing
order or decreasing order.",00:02:52.760,00:02:55.660
"Let's just call it
increasing order for now.",00:02:55.660,00:02:58.690
"Or if they're records,
and they're not numbers,",00:02:58.690,00:03:01.650
"then you have to provide
a comparison function",00:03:01.650,00:03:04.520
"to determine which record is
smaller than another record.",00:03:04.520,00:03:08.050
"And that's another
input that you",00:03:08.050,00:03:09.520
"have to have in order
to do the sorting.",00:03:09.520,00:03:12.980
"So it doesn't really
matter what the items are",00:03:12.980,00:03:15.310
"as long as you have the
comparison function.",00:03:15.310,00:03:17.580
"Think of it as less
than or equal to.",00:03:17.580,00:03:19.930
"And if you have that and
it's straightforward,",00:03:19.930,00:03:23.750
"obviously, to check that 3
is less than 4, et cetera.",00:03:23.750,00:03:27.090
"But it may be a little
more complicated",00:03:27.090,00:03:29.640
"for more sophisticated
sorting applications.",00:03:29.640,00:03:32.990
"But the bottom line is that if
you have your algorithm that",00:03:32.990,00:03:36.570
"takes a comparison
function as an input,",00:03:36.570,00:03:39.120
"you're going to be able to,
after a certain amount of time,",00:03:39.120,00:03:42.670
get B 0 n.,00:03:42.670,00:03:45.100
"Now if you wanted to find the
median of the set of numbers",00:03:45.100,00:03:48.680
"that were originally
in the array A,",00:03:48.680,00:03:51.720
"what would you do once you
have the sorted array B?",00:03:51.720,00:03:56.090
"AUDIENCE: Isn't there a more
efficient algorithm for median?",00:03:56.090,00:03:59.124
PROFESSOR: Absolutely.,00:03:59.124,00:04:00.040
"But this is sort of a side
effect of having a sorted list.",00:04:00.040,00:04:08.120
"If you happen to
have a sorted list,",00:04:08.120,00:04:10.240
"there's many ways
that you could imagine",00:04:10.240,00:04:15.090
building up a sorted list.,00:04:15.090,00:04:16.310
"One way is you have something
that's completely unsorted",00:04:16.310,00:04:19.779
"and you run insertion
sort or merge sort.",00:04:19.779,00:04:22.620
"Another way would be to
maintain a sorted list as you're",00:04:22.620,00:04:25.140
getting items put into the list.,00:04:25.140,00:04:27.660
"So if you happened
to have a sorted list",00:04:27.660,00:04:29.640
"and you need to have this
sorted list for some reason,",00:04:29.640,00:04:32.600
"the point I'm making here
is that finding the median",00:04:32.600,00:04:35.440
is easy.,00:04:35.440,00:04:37.140
"And it's easy because
all you have to do",00:04:37.140,00:04:39.430
"is look at-- depending
on whether n is odd",00:04:39.430,00:04:43.805
or even-- look at B of n over 2.,00:04:43.805,00:04:47.527
"That would give you the
median because you'd",00:04:47.527,00:04:49.360
"have a bunch of numbers
that are less than that",00:04:49.360,00:04:54.210
"and the equal set of numbers
that are greater than that,",00:04:54.210,00:04:56.830
"which is the
definition of median.",00:04:56.830,00:04:59.770
"So this is not necessarily the
best way, as you pointed out,",00:04:59.770,00:05:05.030
of finding the median.,00:05:05.030,00:05:06.400
"But it's constant time if
you have a sorted list.",00:05:06.400,00:05:11.320
"That's the point
I wanted to make.",00:05:11.320,00:05:14.650
"There are other things
that you could do.",00:05:14.650,00:05:16.720
"And this came up
in Erik's lecture,",00:05:16.720,00:05:20.780
"which is the notion of
binary search-- finding",00:05:20.780,00:05:25.570
"an element in an array--
a specific element.",00:05:25.570,00:05:28.650
"You have a list of items--
again a 0 through n.",00:05:28.650,00:05:34.090
"And you're looking for a
specific number or item.",00:05:34.090,00:05:39.600
"You could, obviously,
scan the array,",00:05:43.550,00:05:46.640
"and that would take you
linear time to find this item.",00:05:46.640,00:05:50.260
"If the array happened
to be sorted,",00:05:50.260,00:05:53.100
"then you can find this
in logarithmic time",00:05:53.100,00:05:58.530
"using what's called
binary search.",00:05:58.530,00:06:00.295
"Let's say you're looking
for a specific item.",00:06:03.600,00:06:05.880
Let's call it k.,00:06:05.880,00:06:08.280
"Binary search, roughly
speaking, would",00:06:08.280,00:06:11.140
"work like-- you go compare
k to, again, B of n over 2,",00:06:11.140,00:06:20.200
"and decide, given
that B is sorted,",00:06:20.200,00:06:23.780
"you get to look at
1/2 of the array.",00:06:23.780,00:06:28.400
"If B of n over 2 is not
exactly k, then-- well,",00:06:28.400,00:06:33.080
if it's exactly k you're done.,00:06:33.080,00:06:34.390
"Otherwise, you look
at the left half.",00:06:34.390,00:06:36.770
"You do your divide
and conquer paradigm.",00:06:36.770,00:06:39.670
"And you can do this
in logarithmic time.",00:06:39.670,00:06:42.820
"So keep this in mind,
because binary search",00:06:42.820,00:06:45.700
"is going to come up
in today's lecture",00:06:45.700,00:06:48.530
and again in other lectures.,00:06:48.530,00:06:50.760
"It's really a great
paradigm of divide",00:06:50.760,00:06:53.750
"and conquer--
probably the simplest.",00:06:53.750,00:06:56.020
"And it, essentially,
takes something",00:06:56.020,00:06:57.690
"that's linear--
a linear search--",00:06:57.690,00:07:01.040
"and turns it into
logarithmic search.",00:07:01.040,00:07:03.770
"So those are a
couple of problems",00:07:03.770,00:07:06.540
"that become easy if
you have a sorted list.",00:07:06.540,00:07:10.950
"And there's some not
so obvious applications",00:07:10.950,00:07:21.270
"of sorting-- for example,
data compression.",00:07:21.270,00:07:25.150
"If you wanted to
compress a file,",00:07:25.150,00:07:27.790
"one of the things that
you could do is to--",00:07:27.790,00:07:30.530
"and it's a set of items--
you could sort the items.",00:07:30.530,00:07:35.330
"And that automatically
finds duplicates.",00:07:35.330,00:07:37.870
"And you could say, if I have 100
items that are all identical,",00:07:37.870,00:07:42.940
"I'm going to compress the file
by representing the item once",00:07:42.940,00:07:47.779
"and, then, having
a number associated",00:07:47.779,00:07:49.320
"with the frequency of that
item-- similar to what",00:07:49.320,00:07:52.770
document distance does.,00:07:52.770,00:07:54.440
"Document distance can
be viewed as a way",00:07:54.440,00:07:57.750
"of compressing
your initial input.",00:07:57.750,00:07:59.770
"Obviously, you lose the works of
Shakespeare or whatever it was.",00:07:59.770,00:08:03.240
"And it becomes a bunch
of words and frequencies.",00:08:03.240,00:08:06.560
"But it is something that
compresses the input",00:08:06.560,00:08:12.870
"and gives you a
different representation.",00:08:12.870,00:08:15.590
"And so people use sorting as a
subroutine in data compression.",00:08:15.590,00:08:20.395
Computer graphics uses sorting.,00:08:23.190,00:08:27.360
"Most of the time,
when you render",00:08:27.360,00:08:30.560
"scenes in computer graphics,
you have many layers",00:08:30.560,00:08:32.870
corresponding to the scenes.,00:08:32.870,00:08:34.559
"It turns out that,
in computer graphics,",00:08:34.559,00:08:38.550
"most of the time you're
actually rendering",00:08:38.550,00:08:40.299
"front to back because,
when you have a big opaque",00:08:40.299,00:08:44.410
"object in front, you want
to render that first,",00:08:44.410,00:08:48.887
"so you don't have to worry
about everything that's",00:08:48.887,00:08:50.970
"occluded by this
big opaque object.",00:08:50.970,00:08:54.060
"And that makes things
more efficient.",00:08:54.060,00:08:56.590
"And so you keep things
sorted front to back,",00:08:56.590,00:08:58.700
"most of the time, in
computer graphics rendering.",00:08:58.700,00:09:01.160
"But some of the time, if you're
worried about transparency,",00:09:01.160,00:09:03.860
"you have to render
things back to front.",00:09:03.860,00:09:05.660
"So typically, you
have sorted lists",00:09:05.660,00:09:08.390
"corresponding to the different
objects in both orders--",00:09:08.390,00:09:11.550
"both increasing order
and decreasing order.",00:09:11.550,00:09:13.730
And you're maintaining that.,00:09:13.730,00:09:15.230
"So sorting is a real
important subroutine",00:09:15.230,00:09:19.190
"in pretty much any sophisticated
application you look at.",00:09:19.190,00:09:23.090
"So it's worthwhile to look
at the variety of sorting",00:09:23.090,00:09:26.780
algorithms that are out there.,00:09:26.780,00:09:28.350
"And we're going to do
some simple ones, today.",00:09:28.350,00:09:30.432
"But if you go and
look at Wikipedia",00:09:30.432,00:09:31.890
"and do a Google search,
there's all sorts",00:09:31.890,00:09:35.270
"of sorts like cocktail
sort, and bitonic sort,",00:09:35.270,00:09:38.030
and what have you.,00:09:38.030,00:09:41.900
"And there's reasons why each of
these sorting algorithms exist.",00:09:41.900,00:09:45.900
"Because in specific
cases, they end up",00:09:45.900,00:09:49.830
"winning on types of inputs
or types of problems.",00:09:49.830,00:09:53.055
"So let's take a look at our
first sorting algorithm.",00:09:55.660,00:09:59.470
"I'm not going to write code
but it will be in the notes.",00:09:59.470,00:10:03.640
"And it is in your document
distance Python files.",00:10:03.640,00:10:08.860
"But I'll just give
you pseudocode here",00:10:08.860,00:10:10.770
"and walk through what
insertion sort looks like",00:10:10.770,00:10:13.750
"because the purpose
of describing",00:10:13.750,00:10:17.460
"this algorithm to you is
to analyze its complexity.",00:10:17.460,00:10:20.756
"We need to do some
counting here,",00:10:20.756,00:10:22.130
"with respect to this
algorithm, to figure out",00:10:22.130,00:10:25.230
"how fast it's going to run
in and what the worst case",00:10:25.230,00:10:28.610
complexity is.,00:10:28.610,00:10:30.280
So what is insertion sort?,00:10:30.280,00:10:32.585
"For i equals 1, 2, through n,
given an input to be sorted,",00:10:32.585,00:10:41.780
"what we're going to do is
we're going to insert A of i",00:10:41.780,00:10:46.600
in the right position.,00:10:46.600,00:10:48.470
"And we're going
to assume that we",00:10:48.470,00:10:51.170
"are sort of midway through
the sorting process, where",00:10:51.170,00:10:55.220
"we have sorted A 0
through i minus 1.",00:10:55.220,00:11:00.920
"And we're going to
expand this to this array",00:11:00.920,00:11:04.340
to have i plus 1 elements.,00:11:04.340,00:11:07.590
"And A of i is going
to get inserted",00:11:07.590,00:11:09.650
into the correct position.,00:11:09.650,00:11:12.830
"And we're going to do
this by pairwise swaps",00:11:12.830,00:11:23.640
"down to the correct position
for the number that is initially",00:11:23.640,00:11:32.730
in A of i.,00:11:32.730,00:11:33.490
"So let's go through
an example of this.",00:11:36.050,00:11:42.410
"We're going to sort
in increasing order.",00:11:42.410,00:11:44.840
Just have six numbers.,00:11:44.840,00:11:45.885
"And initially, we
have 5, 2, 4, 6, 1, 3.",00:11:50.430,00:11:54.805
"And we're going to
take a look at this.",00:11:54.805,00:11:56.430
"And you start with the index
1, or the second element,",00:11:56.430,00:12:00.550
"because the very first
element-- it's a single element",00:12:00.550,00:12:03.620
"and it's already
sorted by definition.",00:12:03.620,00:12:06.050
But you start from here.,00:12:06.050,00:12:07.930
"And this is what
we call our key.",00:12:07.930,00:12:10.890
"And that's essentially a pointer
to where we're at, right now.",00:12:10.890,00:12:15.250
"And the key keeps
moving to the right",00:12:15.250,00:12:17.020
"as we go through the different
steps of the algorithm.",00:12:17.020,00:12:20.007
"And so what you do
is you look at this",00:12:20.007,00:12:21.590
and you have-- this is A of i.,00:12:21.590,00:12:24.830
That's your key.,00:12:24.830,00:12:26.030
"And you have A of
0 to 0, which is 5.",00:12:26.030,00:12:30.070
"And since we want to
sort in increasing order,",00:12:30.070,00:12:34.260
this is not sorted.,00:12:34.260,00:12:35.940
And so we do a swap.,00:12:35.940,00:12:37.720
"So what this would do in
this step is to do a swap.",00:12:37.720,00:12:42.400
"And we would go obtain
2, 5, 4, 6, 1, 3.",00:12:42.400,00:12:51.830
"So all that's happened here,
in this step-- in the very",00:12:51.830,00:12:55.080
"first step where the key
is in the second position--",00:12:55.080,00:12:57.360
is one swap happened.,00:12:57.360,00:13:00.020
"Now, your key is
here, at item 4.",00:13:00.020,00:13:03.340
"Again, you need to put
4 into the right spot.",00:13:03.340,00:13:05.980
And so you do pairwise swaps.,00:13:05.980,00:13:08.670
"And in this case, you
have to do one swap.",00:13:08.670,00:13:11.280
"And you get 2, 4, 5.",00:13:11.280,00:13:12.750
"And you're done
with this iteration.",00:13:12.750,00:13:15.650
"So what happens here is
you have 2, 4, 5, 6, 1, 3.",00:13:15.650,00:13:27.850
"And now, the key
is over here, at 6.",00:13:27.850,00:13:33.010
"Now, at this point,
things are kind of easy,",00:13:33.010,00:13:37.860
"in the sense that you look
at it and you say, well, I",00:13:37.860,00:13:41.180
"know this part is
already started.",00:13:41.180,00:13:43.480
6 is greater than 5.,00:13:43.480,00:13:44.970
So you have to do nothing.,00:13:44.970,00:13:47.000
"So there's no swaps that
happen in this step.",00:13:47.000,00:13:51.530
"So all that happens
here is you're",00:13:51.530,00:13:56.440
"going to move the key to
one step to the right.",00:13:56.440,00:14:02.280
"So you have 2, 4, 5, 6, 1, 3.",00:14:02.280,00:14:06.370
And your key is now at 1.,00:14:06.370,00:14:10.270
"Here, you have to do more work.",00:14:10.270,00:14:11.910
"Now, you see one aspect of the
complexity of this algorithm--",00:14:11.910,00:14:16.770
"given that you're doing
pairwise swaps-- the way",00:14:16.770,00:14:19.470
"this algorithm was defined, in
pseudocode, out there, was I'm",00:14:19.470,00:14:23.420
"going to use pairwise swaps
to find the correct position.",00:14:23.420,00:14:27.760
"So what you're going
to do is you're",00:14:27.760,00:14:29.640
"going to have to
swap first 1 and 6.",00:14:29.640,00:14:34.080
"And then you'll
swap-- 1 is over here.",00:14:34.080,00:14:36.310
"So you'll swap this
position and that position.",00:14:36.310,00:14:39.970
"And then you'll
swap-- essentially,",00:14:39.970,00:14:44.580
"do 4 swaps to get to
the point where you have",00:14:44.580,00:14:49.910
"1, 2, 4, 5, 6, 3.",00:14:49.910,00:14:52.970
So this is the result.,00:14:52.970,00:14:56.650
"1, 2, 4, 5, 6, 3.",00:14:59.190,00:15:03.770
"And the important thing
to understand, here,",00:15:03.770,00:15:06.360
"is that you've done
four swaps to get 1",00:15:06.360,00:15:09.050
to the correct position.,00:15:09.050,00:15:10.160
"Now, you could imagine a
different data structure",00:15:10.160,00:15:12.480
"where you move this over
there and you shift them",00:15:12.480,00:15:15.470
all to the right.,00:15:15.470,00:15:16.930
"But in fact, that shifting
of these four elements",00:15:16.930,00:15:20.230
"is going to be computed
in our model as four",00:15:20.230,00:15:23.630
"operations, or
four steps, anyway.",00:15:23.630,00:15:26.244
"So there's no getting
away from the fact",00:15:26.244,00:15:27.910
"that you have to do
four things here.",00:15:27.910,00:15:30.660
"And the way the code that
we have for insertion sort",00:15:30.660,00:15:36.830
"does this is by
using pairwise swaps.",00:15:36.830,00:15:39.400
So we're almost done.,00:15:39.400,00:15:41.470
"Now, we have the key at 3.",00:15:41.470,00:15:49.490
"And now, 3 needs to get put
into the correct position.",00:15:49.490,00:15:52.910
"And so you've got
to do a few swaps.",00:15:52.910,00:15:55.350
This is the last step.,00:15:55.350,00:15:58.320
"And what happens here is 3 is
going to get swapped with 6.",00:15:58.320,00:16:03.580
"And then 3 needs to
get swapped with 5.",00:16:03.580,00:16:06.520
"And then 3 needs to
get swapped with 4.",00:16:06.520,00:16:09.770
"And then, since 3 is
greater than 2, you're done.",00:16:09.770,00:16:12.985
"So you have 1, 2, 3, 4, 5, 6.",00:16:12.985,00:16:16.325
And that's it.,00:16:18.880,00:16:21.180
"So, analysis.",00:16:21.180,00:16:22.820
How many steps do I have?,00:16:25.380,00:16:26.630
AUDIENCE: n squared?,00:16:30.670,00:16:32.150
"PROFESSOR: No, how
many steps do I have?",00:16:32.150,00:16:36.310
"I guess that wasn't
a good question.",00:16:36.310,00:16:40.120
"If I think of a step as
being a movement of the key,",00:16:40.120,00:16:43.930
how many steps do I have?,00:16:43.930,00:16:46.215
I have theta n steps.,00:16:46.215,00:16:49.930
"And in this case, you can
think of it as n minus 1 steps,",00:16:49.930,00:16:56.570
since you started with 2.,00:16:56.570,00:16:58.030
"But let's just call
it theta n steps,",00:16:58.030,00:17:03.900
in terms of key positions.,00:17:03.900,00:17:06.780
And you're right.,00:17:10.060,00:17:11.150
"It is n square because,
at any given step,",00:17:11.150,00:17:15.349
"it's quite possible that
I have to do theta n work.",00:17:15.349,00:17:19.730
"And one example is
this one, right here,",00:17:19.730,00:17:22.400
where I had to do four swaps.,00:17:22.400,00:17:25.160
"And in general, you can
construct a scenario",00:17:25.160,00:17:27.599
"where, towards the
end of the algorithm,",00:17:27.599,00:17:31.470
you'd have to do theta n work.,00:17:31.470,00:17:34.120
"But if you had a list
that was reverse sorted.",00:17:34.120,00:17:37.560
"You would, essentially,
have to do, on an average n",00:17:37.560,00:17:40.960
"by two swaps as you go
through each of the steps.",00:17:40.960,00:17:43.850
And that's theta n.,00:17:43.850,00:17:45.300
So each step is theta n swaps.,00:17:45.300,00:17:52.150
"And when I say
swaps, I could also",00:17:55.930,00:17:58.740
"say each step is theta
n compares and swaps.",00:17:58.740,00:18:06.645
"And this is going
to be important",00:18:06.645,00:18:08.020
"because I'm going to ask
you an interesting question",00:18:08.020,00:18:10.430
in a minute.,00:18:10.430,00:18:11.700
But let me summarize.,00:18:11.700,00:18:13.840
"What I have here is a
theta n squared algorithm.",00:18:13.840,00:18:16.470
"The reason this is
a theta n squared",00:18:16.470,00:18:17.970
"algorithm is because
I have theta n steps",00:18:17.970,00:18:22.760
and each step is theta n.,00:18:22.760,00:18:26.860
"When I'm counting,
what am I counting",00:18:26.860,00:18:29.140
it terms of operations?,00:18:29.140,00:18:30.730
"The assumption here--
unspoken assumption--",00:18:30.730,00:18:33.510
"has been that an operation
is a compare and a swap",00:18:33.510,00:18:36.810
"and they're, essentially,
equal in cost.",00:18:36.810,00:18:39.540
"And in most computers,
that's true.",00:18:39.540,00:18:41.850
"You have a single
instruction and, say, the x86",00:18:41.850,00:18:45.210
"or the MIPS architecture
that can do a compare,",00:18:45.210,00:18:47.700
"and the same thing for
swapping registers.",00:18:47.700,00:18:50.660
"So perfectly
reasonably assumption",00:18:50.660,00:18:52.640
"that compares and
swaps for numbers",00:18:52.640,00:18:56.480
have exactly the same cost.,00:18:56.480,00:18:58.410
"But if you had a record and
you were comparing records,",00:18:58.410,00:19:01.900
"and the comparison function that
you used for the records was",00:19:01.900,00:19:05.700
"in itself a method
call or a subroutine,",00:19:05.700,00:19:08.820
"it's quite possible
that all you're doing",00:19:08.820,00:19:11.290
"is swapping pointers or
references to do the swap,",00:19:11.290,00:19:15.600
"but the comparison could be
substantially more expensive.",00:19:15.600,00:19:17.985
"Most of the time-- and
we'll differentiate",00:19:22.870,00:19:24.920
"if it becomes
necessary-- we're going",00:19:24.920,00:19:27.150
"to be counting comparisons
in the sorting algorithms",00:19:27.150,00:19:29.560
that we'll be putting out.,00:19:29.560,00:19:31.230
"And we'll be assuming that
either comparison swaps are",00:19:31.230,00:19:36.130
"roughly the same or
that compares are--",00:19:36.130,00:19:41.040
"and we'll say which one,
of course-- that compares",00:19:41.040,00:19:44.570
"are substantially more
expensive than swaps.",00:19:44.570,00:19:47.830
"So if you had either of those
cases for insertion sort,",00:19:47.830,00:19:52.270
"you have a theta n
squared algorithm.",00:19:52.270,00:19:54.226
"You have theta n
squared compares",00:19:54.226,00:19:55.600
and theta n squared swaps.,00:19:55.600,00:19:58.200
"Now, here's a question.",00:19:58.200,00:20:00.780
"Let's say that compares are
more expensive than swaps.",00:20:00.780,00:20:11.179
"And so, I'm concerned
about the theta",00:20:11.179,00:20:12.720
n squared comparison cost.,00:20:12.720,00:20:14.750
"I'm not as concerned, because of
the constant factors involved,",00:20:17.270,00:20:20.880
"with the theta n
squared swap cost.",00:20:20.880,00:20:22.710
This is a question question.,00:20:25.410,00:20:28.730
"What's a simple fix-- change
to this algorithm that",00:20:28.730,00:20:33.590
"would give me a better
complexity in the case",00:20:33.590,00:20:37.260
"where compares are
more expensive,",00:20:37.260,00:20:39.900
"or I'm only looking at the
complexity of compares.",00:20:39.900,00:20:43.300
"So the theta
whatever of compares.",00:20:43.300,00:20:46.990
Anyone?,00:20:46.990,00:20:47.950
"Yeah, back there.",00:20:47.950,00:20:48.661
AUDIENCE: [INAUDIBLE],00:20:48.661,00:20:49.536
"PROFESSOR: You could
compare with the middle.",00:20:56.356,00:20:58.230
What did I call it?,00:20:58.230,00:20:59.021
I called it something.,00:21:01.910,00:21:03.120
"What you just said, I
called it something.",00:21:03.120,00:21:06.161
AUDIENCE: Binary search.,00:21:06.161,00:21:07.160
PROFESSOR: Binary search.,00:21:07.160,00:21:07.740
That's right.,00:21:07.740,00:21:08.310
Two cushions for this one.,00:21:08.310,00:21:10.280
"So you pick them
up after lecture.",00:21:10.280,00:21:12.221
So you're exactly right.,00:21:12.221,00:21:13.220
You got it right.,00:21:13.220,00:21:13.928
"I called it binary
search, up here.",00:21:13.928,00:21:18.160
"And so you can
take insertion sort",00:21:18.160,00:21:21.620
"and you can sort of trivially
turn it into a theta n log n",00:21:21.620,00:21:24.800
"algorithm if we
are talking about n",00:21:24.800,00:21:27.200
being the number of compares.,00:21:27.200,00:21:29.910
"And all you have to do
to do that is to say,",00:21:29.910,00:21:32.425
"you know what, I'm
going to replace",00:21:32.425,00:21:34.280
this with binary search.,00:21:34.280,00:21:37.950
"And you can do that-- and
that was the key observation--",00:21:37.950,00:21:42.720
"because A of 0 through i
minus 1 is already sorted.",00:21:42.720,00:21:47.990
"And so you can do binary search
on that part of the array.",00:21:47.990,00:21:51.909
So let me just write that down.,00:21:51.909,00:21:53.200
"Do a binary search on A
of 0 through i minus 1,",00:21:56.750,00:22:04.000
which is already sorted.,00:22:04.000,00:22:05.095
"And essentially, you can think
of it as theta log i time,",00:22:10.540,00:22:16.780
and for each of those steps.,00:22:16.780,00:22:18.070
"And so then you get your
theta n log n theta n log",00:22:18.070,00:22:27.251
n in terms of compares.,00:22:27.251,00:22:30.410
"Does this help the swaps
for an array data structure?",00:22:30.410,00:22:37.940
"No, because binary search
will require insertion",00:22:37.940,00:22:41.280
into A of 0 though i minus 1.,00:22:41.280,00:22:44.670
So here's the problem.,00:22:44.670,00:22:45.880
"Why don't we have a full-fledged
theta n log n algorithm,",00:22:45.880,00:22:50.430
"regardless of the cost
of compares or swaps?",00:22:50.430,00:22:53.940
We don't quite have that.,00:22:53.940,00:22:55.470
"We don't quite have that because
we need to insert our A of i",00:22:55.470,00:23:02.950
"into the right position into
A of 0 through i minus 1.",00:23:02.950,00:23:07.850
"You do that if you have
an array structure,",00:23:07.850,00:23:09.790
it might get into the middle.,00:23:09.790,00:23:10.998
"And you have to shift
things over to the right.",00:23:10.998,00:23:13.337
"And when you shift
things over to the right,",00:23:13.337,00:23:15.170
"in the worst case, you may
be shifting a lot of things",00:23:15.170,00:23:17.090
over to the right.,00:23:17.090,00:23:17.980
"And that gets back to worst
case complexity of theta n.",00:23:17.980,00:23:20.630
"So a binary search
in insertion sort",00:23:23.200,00:23:27.000
"gives you theta n
log n for compares.",00:23:27.000,00:23:29.197
"But it's still theta
n squared for swaps.",00:23:29.197,00:23:30.905
"So as you can see,
there's many varieties",00:23:35.000,00:23:36.805
of sorting algorithms.,00:23:36.805,00:23:37.770
"We just looked at
a couple of them.",00:23:37.770,00:23:39.850
"And they were both
insertion sort.",00:23:39.850,00:23:43.010
"The second one
that I just put up",00:23:43.010,00:23:45.040
"is, I guess, technically
called binary insertion sort",00:23:45.040,00:23:48.900
because it does binary search.,00:23:48.900,00:23:50.710
"And the vanilla
insertion sort is",00:23:50.710,00:23:53.000
"the one that you have the code
for in the doc dis program,",00:23:53.000,00:23:56.676
"or at least one of
the doc dis files.",00:23:56.676,00:23:59.400
"So let's move on and talk
about a different algorithm.",00:23:59.400,00:24:04.620
"So what we'd like to
do, now-- this class",00:24:04.620,00:24:06.830
is about constant improvement.,00:24:06.830,00:24:09.120
We're never happy.,00:24:09.120,00:24:11.480
"We always want to do
a little bit better.",00:24:11.480,00:24:14.370
"And eventually, once
we run out of room",00:24:14.370,00:24:16.864
"from an asymptotic
standpoint, you",00:24:16.864,00:24:18.280
"take these other classes
where you try and improve",00:24:18.280,00:24:20.363
"constant factors and
get 10%, and 5%, and 1%,",00:24:20.363,00:24:24.380
"and so on, and so forth.",00:24:24.380,00:24:25.560
"But we'll stick to improving
asymptotic complexity.",00:24:25.560,00:24:31.200
"And we're not quite happy
with binary insertion sort",00:24:31.200,00:24:34.190
"because, in the case of numbers,
our binary insertion sort",00:24:34.190,00:24:37.050
"has theta n squared complexity,
if you look at swaps.",00:24:37.050,00:24:40.709
"So we'd like to go find an
algorithm that is theta n log",00:24:40.709,00:24:43.042
n.,00:24:43.042,00:24:44.810
"And I guess, eventually,
we'll have to stop.",00:24:44.810,00:24:49.600
But Erik will take care of that.,00:24:49.600,00:24:51.260
There's a reason to stop.,00:24:53.900,00:24:54.970
"It's when you can prove that
you can't do any better.",00:24:54.970,00:24:58.620
"And so we'll get to
that, eventually.",00:24:58.620,00:25:01.210
"So merge sort is also something
that you've probably seen.",00:25:01.210,00:25:04.685
"But there probably
will be a couple",00:25:07.277,00:25:08.735
"of subtleties that come out as
I describe this algorithm that,",00:25:08.735,00:25:12.440
"hopefully, will be interesting
to those of you who already",00:25:12.440,00:25:15.340
know merge sort.,00:25:15.340,00:25:16.810
"And for those of you who don't,
it's a very pretty algorithm.",00:25:16.810,00:25:21.030
"It's a standard recursion
algorithm-- recursive",00:25:21.030,00:25:26.930
"algorithm-- similar
to a binary search.",00:25:26.930,00:25:30.620
"What we do, here, is we have
an array, A. We split it",00:25:30.620,00:25:34.780
"into two parts, L and R.
And essentially, we kind of",00:25:34.780,00:25:42.095
"do no work, really.",00:25:42.095,00:25:43.950
"In terms of the L and R in
the sense that we just call,",00:25:43.950,00:25:49.814
"we keep splitting,
splitting, splitting.",00:25:49.814,00:25:51.480
"And all the work is
done down at the bottom",00:25:51.480,00:25:54.020
"in this routine called
merge, where we are merging",00:25:54.020,00:25:57.570
"a pair of elements
at the leaves.",00:25:57.570,00:26:00.110
"And then, we merge two
pairs and get four elements.",00:26:00.110,00:26:04.490
"And then we merge four tuples
of elements, et cetera,",00:26:04.490,00:26:08.630
and go all the way up.,00:26:08.630,00:26:10.080
"So while I'm just saying L
terms into L prime, out here,",00:26:10.080,00:26:18.990
"there's no real
explicit code that you",00:26:18.990,00:26:20.990
"can see that turns
L into L prime.",00:26:20.990,00:26:23.870
It happens really later.,00:26:23.870,00:26:25.630
"There's no real
sorting code, here.",00:26:25.630,00:26:27.190
It happens in the merge routine.,00:26:27.190,00:26:28.790
"And you'll see
that quite clearly",00:26:28.790,00:26:30.649
when we run through an example.,00:26:30.649,00:26:31.940
"So you have L and R turn
into L prime and R prime.",00:26:34.960,00:26:41.500
"And what we end up getting
is a sorted array, A.",00:26:41.500,00:26:52.310
"And we have what's called
a merge routine that",00:26:52.310,00:26:58.900
"takes L prime and R
prime and merges them",00:26:58.900,00:27:01.110
into the sorted array.,00:27:01.110,00:27:02.400
"So at the top level, what
you see is split into two,",00:27:02.400,00:27:09.270
"and do a merge, and get
to the sorted array.",00:27:09.270,00:27:13.280
The input is of size n.,00:27:13.280,00:27:16.680
"You have two arrays
of size n over 2.",00:27:16.680,00:27:24.690
"These are two sorted
arrays of size n over 2.",00:27:24.690,00:27:33.210
"And then, finally, you have
a sorted array of size n.",00:27:33.210,00:27:39.480
"So if you want to follow
the recursive of execution",00:27:42.116,00:27:44.240
"of this in a small
example, then you'll",00:27:44.240,00:27:49.870
be able to see how this works.,00:27:49.870,00:27:53.790
"And we'll do a fairly
straightforward example",00:27:53.790,00:27:56.120
with 8 elements.,00:27:56.120,00:27:58.200
"So at the top level--
before we get there, merge",00:27:58.200,00:28:03.180
"is going to assume that
you have two sorted arrays,",00:28:03.180,00:28:08.640
and merge them together.,00:28:08.640,00:28:11.700
"That's the invariant in merge
sort, or for the merge routine.",00:28:11.700,00:28:15.960
"It assumes the inputs are
sorted-- L and R. Actually",00:28:15.960,00:28:19.570
"I should say, L
prime and R prime.",00:28:19.570,00:28:22.800
"So let's say you have
20, 13, 7, and 2.",00:28:22.800,00:28:27.624
"You have 12, 11, 9, and 1.",00:28:27.624,00:28:31.320
And this could be L prime.,00:28:31.320,00:28:33.400
And this could be R prime.,00:28:33.400,00:28:36.840
"What you have is what we
call a two finger algorithm.",00:28:36.840,00:28:39.650
"And so you've got two
fingers and each of them",00:28:39.650,00:28:42.380
point to something.,00:28:42.380,00:28:44.162
"And in this case, one
of them is pointing",00:28:44.162,00:28:45.870
"to L. My left finger
is pointing to L prime,",00:28:45.870,00:28:49.190
or some element L prime.,00:28:49.190,00:28:50.800
"My right finger is pointing
to some element in R prime.",00:28:50.800,00:28:53.850
"And I'm going to
compare the two elements",00:28:53.850,00:28:56.820
that my fingers are pointing to.,00:28:56.820,00:28:58.740
"And I'm going to
choose, in this case,",00:28:58.740,00:29:02.170
the smaller of those elements.,00:29:02.170,00:29:03.840
"And I'm going to put them
into the sorted array.",00:29:03.840,00:29:07.790
So start out here.,00:29:07.790,00:29:10.970
Look at that and that.,00:29:10.970,00:29:12.480
And I compared 2 and 1.,00:29:12.480,00:29:14.266
And which is smaller?,00:29:14.266,00:29:15.140
1 is smaller.,00:29:15.140,00:29:16.310
So I'm going to write 1 down.,00:29:16.310,00:29:19.130
"This is a two finger
algo for merge.",00:29:19.130,00:29:23.720
And I put 1 down.,00:29:23.720,00:29:24.880
"When I put 1 down, I
had to cross out 1.",00:29:24.880,00:29:27.380
"So effectively, what
happens is-- let",00:29:27.380,00:29:29.395
"me just circle that
instead of crossing it out.",00:29:29.395,00:29:31.460
And my finger moves up to 9.,00:29:31.460,00:29:35.450
So now I'm pointing at 2 and 9.,00:29:35.450,00:29:38.110
And I repeat this step.,00:29:38.110,00:29:40.080
"So now, in this
case, 2 is smaller.",00:29:40.080,00:29:41.870
"So I'm going to go
ahead and write 2 down.",00:29:41.870,00:29:44.040
"And I can cross out 2 and
move my finger up to 7.",00:29:44.040,00:29:49.420
And so that's it.,00:29:49.420,00:29:50.840
"I won't bore you with
the rest of the steps.",00:29:50.840,00:29:54.010
It's essentially walking up.,00:29:54.010,00:29:56.114
"You have a couple of
pointers and you're",00:29:56.114,00:29:57.780
walking up these two arrays.,00:29:57.780,00:29:59.920
"And you're writing down 1,
2, 7, 9, 11, 12, 13, 20.",00:29:59.920,00:30:07.230
And that's your merge routine.,00:30:07.230,00:30:08.730
"And all of the work, really,
is done in the merge routine",00:30:08.730,00:30:12.330
"because, other than
that, the body is simply",00:30:12.330,00:30:15.460
a recursive call.,00:30:15.460,00:30:16.620
"You have to, obviously,
split the array.",00:30:16.620,00:30:18.420
"But that's fairly
straightforward.",00:30:18.420,00:30:20.110
"If you have an array, A 0
through n-- and depending on",00:30:20.110,00:30:24.600
"whether n is odd
or even-- you could",00:30:24.600,00:30:28.300
"imagine that you set L
to be A 0 n by 2 minus 1,",00:30:28.300,00:30:38.530
and R similarly.,00:30:38.530,00:30:41.420
"And so you just split it
halfway in the middle.",00:30:41.420,00:30:44.086
"I'll talk about that
a little bit more.",00:30:44.086,00:30:45.710
"There's a subtlety
associated with that",00:30:45.710,00:30:47.334
"that we'll get to
in a few minutes.",00:30:47.334,00:30:51.200
"But to finish up in terms of
the computation of merge sort.",00:30:51.200,00:30:55.280
This is it.,00:30:55.280,00:30:56.110
"The merge routine is doing
most, if not all, of the work.",00:30:56.110,00:31:00.827
"And this two finger
algorithm is going",00:31:00.827,00:31:02.410
"to be able to take
two sorted arrays",00:31:02.410,00:31:04.630
"and put them into a
single sorted array",00:31:04.630,00:31:09.550
"by interspersing, or
interleaving, these elements.",00:31:09.550,00:31:13.150
"And what's the
complexity of merge",00:31:13.150,00:31:15.000
"if I have two arrays
of size n over 2, here?",00:31:15.000,00:31:18.710
What do I have?,00:31:18.710,00:31:21.810
AUDIENCE: n.,00:31:21.810,00:31:22.590
PROFESSOR: n.,00:31:22.590,00:31:23.731
"We'll give you a cushion, too.",00:31:23.731,00:31:24.980
theta n complexity.,00:31:28.050,00:31:29.165
So far so good.,00:31:35.470,00:31:36.290
"I know you know the
answer as to what",00:31:38.830,00:31:41.640
the complexity of merge sort is.,00:31:41.640,00:31:43.550
"But I'm guessing
that most of you",00:31:43.550,00:31:45.180
"won't be able to prove it to me
because I'm kind of a hard guy",00:31:45.180,00:31:47.900
to prove something to.,00:31:47.900,00:31:50.920
"And I could always say,
no, I don't believe you",00:31:50.920,00:31:53.040
or I don't understand.,00:31:53.040,00:31:53.956
"The complexity-- and you've
said this before, in class,",00:31:57.960,00:32:00.880
"and I think Erik's
mentioned it--",00:32:00.880,00:32:02.580
"the overall complexity of this
algorithm is theta n log n",00:32:02.580,00:32:08.370
And where does that come from?,00:32:08.370,00:32:09.810
How do you prove that?,00:32:09.810,00:32:11.790
"And so what we'll do, now,
is take a look at merge sort.",00:32:11.790,00:32:16.840
"And we'll look at
the recursion tree.",00:32:16.840,00:32:19.070
"And we'll try and--
there are many ways",00:32:19.070,00:32:20.695
"of proving that merge
sort is theta n log n.",00:32:20.695,00:32:23.370
"The way we're
going to do this is",00:32:23.370,00:32:25.860
what's called proof by picture.,00:32:25.860,00:32:28.640
"And it's not an established
proof technique,",00:32:28.640,00:32:32.290
"but it's something
that is very helpful",00:32:32.290,00:32:35.020
"to get an intuition
behind the proof",00:32:35.020,00:32:38.100
and why the result is true.,00:32:38.100,00:32:40.441
"And you can always
take that and you",00:32:40.441,00:32:41.940
"can formalize it and
make this something",00:32:41.940,00:32:47.030
that everyone believes.,00:32:47.030,00:32:49.680
"And we'll also look at
substitution, possibly",00:32:49.680,00:32:52.960
"in section tomorrow,
for recurrence solving.",00:32:52.960,00:32:56.310
"So where we're right now is that
we have a divide and conquer",00:32:56.310,00:33:00.540
"algorithm that has a merge
step that is theta n.",00:33:00.540,00:33:07.710
"And so, if I just look at this
structure that I have here,",00:33:07.710,00:33:12.540
"I can write a recurrence
for merge sort",00:33:12.540,00:33:16.150
that looks like this.,00:33:16.150,00:33:17.966
"So when I say
complexity, I can say",00:33:17.966,00:33:22.720
"T of n, which is the
work done for n items,",00:33:22.720,00:33:26.230
"is going to be some
constant time in order",00:33:26.230,00:33:28.910
to divide the array.,00:33:28.910,00:33:31.940
"So this could be the
part corresponding",00:33:31.940,00:33:34.200
to dividing the array.,00:33:34.200,00:33:36.360
"And there's going to be two
problems of size n over 2.",00:33:36.360,00:33:40.360
And so I have 2 T of n over 2.,00:33:40.360,00:33:42.810
And this is the recursive part.,00:33:42.810,00:33:44.710
"And I'm going to have c times
n, which is the merge part.",00:33:48.650,00:33:53.960
"And that's some constant times
n, which is what we have,",00:33:53.960,00:33:58.910
"here, with respect to
the theta n complexity.",00:33:58.910,00:34:01.890
"So you have a recurrence like
this and I know some of you",00:34:01.890,00:34:04.980
have seen recurrences in 6.042.,00:34:04.980,00:34:07.150
And you know how to solve this.,00:34:07.150,00:34:09.239
"What I'd like to do is show you
this recursion tree expansion",00:34:09.239,00:34:14.469
"that, not only tells you how
to solve this occurrence,",00:34:14.469,00:34:17.989
"but also gives you a means
of solving recurrences where,",00:34:17.989,00:34:23.102
"instead of having c of n, you
have something else out here.",00:34:23.102,00:34:25.560
"You have f of n, which
is a different function",00:34:25.560,00:34:27.790
from the linear function.,00:34:27.790,00:34:29.280
"And this recursion
tree is, in my mind,",00:34:29.280,00:34:33.750
"the simplest way of
arguing the theta n log n",00:34:33.750,00:34:38.650
complexity of merge sort.,00:34:38.650,00:34:41.100
"So what I want to do is
expand this recurrence out.",00:34:41.100,00:34:44.339
And let's do that over here.,00:34:44.339,00:34:45.505
So I have c of n on top.,00:35:06.830,00:35:10.950
"I'm going to ignore this
constant factor because c of n",00:35:10.950,00:35:15.850
dominates.,00:35:15.850,00:35:16.550
So I'll just start with c of n.,00:35:16.550,00:35:18.080
"I want to break things
up, as I do the recursion.",00:35:18.080,00:35:23.450
"So when I go c of n, at
the top level-- that's",00:35:23.450,00:35:26.960
"the work I have to do at
the merge, at the top level.",00:35:26.960,00:35:29.750
"And then when I go down to two
smaller problems, each of them",00:35:29.750,00:35:33.110
is size n over 2.,00:35:33.110,00:35:34.480
"So I do c times n
divided by 2 [INAUDIBLE].",00:35:34.480,00:35:38.440
So this is just a constant c.,00:35:38.440,00:35:41.617
"I didn't want to
write thetas up here.",00:35:41.617,00:35:43.200
You could.,00:35:43.200,00:35:44.440
"And I'll say a little bit
more about that later.",00:35:44.440,00:35:46.760
"But think of this cn as
representing the theta n",00:35:46.760,00:35:49.180
complexity.,00:35:49.180,00:35:50.260
And c is this constant.,00:35:50.260,00:35:52.790
"So c times n, here. c
times n over 2, here.",00:35:52.790,00:35:57.960
"And then when I keep going,
I have c times n over 4,",00:35:57.960,00:36:01.760
"c times n over 4, et cetera,
and so on, and so forth.",00:36:01.760,00:36:08.910
"And when I come down
all the way here,",00:36:08.910,00:36:10.650
"n is eventually going to become
1-- or essentially a constant--",00:36:10.650,00:36:16.670
"and I'm going to have
a bunch of c's here.",00:36:16.670,00:36:20.790
"So here's another question,
that I'd like you to answer.",00:36:20.790,00:36:27.050
"Someone tell me what the number
of levels in this tree are,",00:36:27.050,00:36:31.210
"precisely, and the number
of leaves in this tree are,",00:36:31.210,00:36:34.060
precisely.,00:36:34.060,00:36:35.570
"AUDIENCE: The number of
levels is log n plus 1.",00:36:35.570,00:36:38.061
PROFESSOR: Log n plus 1.,00:36:38.061,00:36:39.060
Log to the base 2 plus 1.,00:36:39.060,00:36:41.169
And the number of leaves?,00:36:41.169,00:36:42.210
"You raised your hand
back there, first.",00:36:48.430,00:36:50.580
Number of leaves.,00:36:50.580,00:36:51.430
AUDIENCE: I think n.,00:36:51.430,00:36:52.880
"PROFESSOR: Yeah, you're right.",00:36:52.880,00:36:54.130
You think right.,00:36:54.130,00:36:56.210
So 1 plus log n and n leaves.,00:36:56.210,00:37:02.520
"When n becomes 1, how
many of them do you have?",00:37:02.520,00:37:05.870
"You're down to a single element,
which is, by definition,",00:37:05.870,00:37:09.470
sorted.,00:37:09.470,00:37:10.580
And you have n leaves.,00:37:10.580,00:37:13.730
So now let's add up the work.,00:37:13.730,00:37:17.020
"I really like this
picture because it's just",00:37:17.020,00:37:20.230
"so intuitive in terms
of getting us the result",00:37:20.230,00:37:23.450
that we're looking for.,00:37:23.450,00:37:25.090
"So you add up the work in each
of the levels of this tree.",00:37:25.090,00:37:30.080
So the top level is cn.,00:37:30.080,00:37:32.190
"The second level is cn because
I added 1/2 and 1/2, cn, cn.",00:37:32.190,00:37:39.790
Wow.,00:37:39.790,00:37:40.750
What symmetry.,00:37:40.750,00:37:43.010
"So you're doing the same
amount of work modulo",00:37:43.010,00:37:50.500
"the constant factors,
here, with what's",00:37:50.500,00:37:54.050
"going on with the c1,
which we've ignored,",00:37:54.050,00:37:56.280
"but roughly the same amount
of work in each of the levels.",00:37:56.280,00:37:59.870
"And now, you know how
many levels there are.",00:37:59.870,00:38:02.570
It's 1 plus log n.,00:38:02.570,00:38:04.850
"So if you want to write
an equation for T of n,",00:38:04.850,00:38:11.930
"it's 1 plus log n times c of
n, which is theta of n log n.",00:38:11.930,00:38:23.030
"So I've mixed in
constants c and thetas.",00:38:26.520,00:38:31.049
"For the purposes of
this description,",00:38:31.049,00:38:32.590
they're interchangeable.,00:38:32.590,00:38:33.950
"You will see recurrences that
look like this, in class.",00:38:33.950,00:38:38.095
And things like that.,00:38:45.210,00:38:46.860
Don't get confused.,00:38:46.860,00:38:48.370
"It's just a constant
multiplicative factor",00:38:48.370,00:38:51.150
"in front of the
function that you have.",00:38:51.150,00:38:54.510
"And it's just a little
easier, I think,",00:38:54.510,00:38:56.230
"to write down these
constant factors",00:38:56.230,00:38:58.140
"and realize that the
amount of work done",00:38:58.140,00:39:00.510
"is the same in
each of the leaves.",00:39:00.510,00:39:02.980
"And once you know the
dimensions of this tree,",00:39:02.980,00:39:06.010
"in terms of levels and in
terms of the number of leaves,",00:39:06.010,00:39:08.930
you get your result.,00:39:08.930,00:39:10.960
"So we've looked at
two algorithm, so far.",00:39:14.560,00:39:17.425
"And insertion sort, if
you talk about numbers,",00:39:26.160,00:39:29.540
is theta n squared for swaps.,00:39:29.540,00:39:31.964
Merge sort is theta n log n.,00:39:31.964,00:39:33.130
"Here's another
interesting question.",00:39:36.270,00:39:38.680
"What is one advantage of
insertion sort over merge sort?",00:39:38.680,00:39:44.720
AUDIENCE: [INAUDIBLE],00:39:50.176,00:39:51.180
PROFESSOR: What does that mean?,00:39:51.180,00:39:52.732
"AUDIENCE: You don't have
to move elements outside",00:39:52.732,00:39:54.773
of [INAUDIBLE].,00:39:54.773,00:39:56.960
PROFESSOR: That's exactly right.,00:39:56.960,00:39:58.420
That's exactly right.,00:39:58.420,00:40:01.330
"So the two guys who
answered the questions",00:40:01.330,00:40:03.270
"before with the levels, and you.",00:40:03.270,00:40:05.840
Come to me after class.,00:40:05.840,00:40:07.740
So that's a great answer.,00:40:07.740,00:40:09.690
"It's in-place
sorting is something",00:40:09.690,00:40:12.180
"that has to do with
auxiliary space.",00:40:12.180,00:40:14.820
"And so what you see, here--
and it was a bit hidden, here.",00:40:14.820,00:40:19.280
"But the fact of the
matter is that you",00:40:19.280,00:40:21.940
had L prime and R prime.,00:40:21.940,00:40:25.530
"And L prime and R prime are
different from L and R, which",00:40:25.530,00:40:29.910
"were the initial halves of
the inputs to the sorting",00:40:29.910,00:40:33.440
algorithm.,00:40:33.440,00:40:34.990
"And what I said here is, we're
going to dump this into A.",00:40:34.990,00:40:38.630
That's what this picture shows.,00:40:38.630,00:40:40.440
"This says sorted
array, A. And so you",00:40:40.440,00:40:43.340
"had to make a copy of the
array-- the two halves L",00:40:43.340,00:40:48.720
"and R-- in order to
do the recursion,",00:40:48.720,00:40:52.270
"and then to take the
results and put them",00:40:52.270,00:40:54.490
"into the sorted array, A.",00:40:54.490,00:40:56.790
"So you needed-- in
merge sort-- you",00:40:56.790,00:40:59.220
needed theta n auxiliary space.,00:40:59.220,00:41:04.060
"So merge sort, you need
theta n extra space.",00:41:04.060,00:41:10.370
"And the definition
of in-place sorting",00:41:10.370,00:41:17.380
"implies that you have theta
1-- constant-- auxiliary space.",00:41:17.380,00:41:21.575
"The auxiliary space
for insertion sort",00:41:24.580,00:41:27.330
"is simply that
temporary variable",00:41:27.330,00:41:30.450
"that you need when
you swap two elements.",00:41:30.450,00:41:33.310
"So when you want to swap
a couple of registers,",00:41:33.310,00:41:35.520
"you gotta store one of the
values in a temporary location,",00:41:35.520,00:41:38.070
"override the other, et cetera.",00:41:38.070,00:41:39.600
"And that's the theta 1 auxiliary
space for insertion sort.",00:41:39.600,00:41:43.190
"So there is an advantage of
the version of insertion sort",00:41:43.190,00:41:47.330
"we've talked about,
today, over merge sort.",00:41:47.330,00:41:49.140
"And if you have a billion
elements, that's potentially",00:41:49.140,00:41:52.827
"something you don't
want to store in memory.",00:41:52.827,00:41:54.660
"If you want to do something
really fast and do everything",00:41:54.660,00:41:57.550
"in cache or main
memory, and you want",00:41:57.550,00:42:00.400
"to sort billions are maybe
even trillions of items,",00:42:00.400,00:42:03.610
"this becomes an
important consideration.",00:42:03.610,00:42:07.740
"I will say that you can
reduce the constant factor",00:42:07.740,00:42:12.930
of the theta n.,00:42:12.930,00:42:14.530
"So in the vanilla
scheme, you could",00:42:14.530,00:42:16.590
"imagine that you have to
have a copy of the array.",00:42:16.590,00:42:18.690
"So if you had n
elements, you essentially",00:42:18.690,00:42:20.900
have n extra items of storage.,00:42:20.900,00:42:24.490
"You can make that n over 2
with a simple coding trick",00:42:24.490,00:42:28.130
by keeping 1/2 of A.,00:42:28.130,00:42:32.710
"You can throw away one of
the L's or one of the R's.",00:42:32.710,00:42:35.800
"And you can get it
down to n over 2.",00:42:35.800,00:42:37.637
"And that turns out--
it's a reasonable thing",00:42:37.637,00:42:39.470
"to do if you have
a billion elements",00:42:39.470,00:42:41.410
"and you want to reduce your
storage by a constant factor.",00:42:41.410,00:42:45.400
So that's one coding trick.,00:42:45.400,00:42:47.130
"Now it turns out that you
can actually go further.",00:42:47.130,00:42:49.630
"And there's a fairly
sophisticated algorithm",00:42:49.630,00:42:52.130
"that's sort of beyond
the scope of 6.006",00:42:52.130,00:42:54.740
that's an in-place merge sort.,00:42:54.740,00:42:56.420
"And this in-place
merge sort is kind of",00:42:59.310,00:43:03.070
"impractical in the sense
that it doesn't do very well",00:43:03.070,00:43:08.590
"in terms of the
constant factors.",00:43:08.590,00:43:10.140
"So while it's in-place and
it's still theta n log n.",00:43:10.140,00:43:15.120
"The problem is that the running
time of an in-place merge sort",00:43:15.120,00:43:19.720
"is much worse than the
regular merge sort that",00:43:19.720,00:43:23.210
uses theta n auxiliary space.,00:43:23.210,00:43:25.510
"So people don't really
use in-place merge sort.",00:43:25.510,00:43:28.100
It's a great paper.,00:43:28.100,00:43:29.360
It's a great thing to read.,00:43:29.360,00:43:31.800
"Its analysis is a bit
sophisticated for double 0 6.",00:43:31.800,00:43:37.080
So we wont go there.,00:43:37.080,00:43:39.030
But it does exist.,00:43:39.030,00:43:40.330
"So you can take merge
sort, and I just",00:43:40.330,00:43:42.003
"want to let you know that
you can do things in-place.",00:43:42.003,00:43:45.230
"In terms of numbers, some
experiments we ran a few years",00:43:45.230,00:43:50.560
"ago-- so these may not
be completely valid",00:43:50.560,00:43:54.650
"because I'm going to
actually give you numbers--",00:43:54.650,00:43:56.650
"but merge sort in Python, if
you write a little curve fit",00:43:56.650,00:44:07.380
"program to do this, is 2.2n log
n microseconds for a given n.",00:44:07.380,00:44:17.790
"So this is the
merge sort routine.",00:44:17.790,00:44:19.625
"And if you look at
insertion sort, in Python,",00:44:22.450,00:44:32.230
"that's something like 0.2
n square microseconds.",00:44:32.230,00:44:39.410
"So you see the
constant factors here.",00:44:39.410,00:44:42.700
"If you do insertion sort in C,
which is a compiled language,",00:44:42.700,00:44:48.230
"then, it's much faster.",00:44:48.230,00:44:50.420
It's about 20 times faster.,00:44:50.420,00:44:52.935
"It's 0.01 n squared
microseconds.",00:44:55.440,00:44:59.230
"So a little bit of
practice on the side.",00:44:59.230,00:45:00.960
We do ask you to write code.,00:45:00.960,00:45:02.714
And this is important.,00:45:02.714,00:45:03.630
"The reason we're
interested in algorithms",00:45:03.630,00:45:04.930
"is because people
want to run them.",00:45:04.930,00:45:06.770
"And what you can see is that
you can actually find an n-- so",00:45:06.770,00:45:13.860
"regardless of whether
you're Python or C,",00:45:13.860,00:45:16.300
"this tells you that asymptotic
complexity is pretty important",00:45:16.300,00:45:20.020
"because, once n gets
beyond about 4,000,",00:45:20.020,00:45:24.140
"you're going to see that
merge sort in Python",00:45:24.140,00:45:27.260
beats insertion sort in C.,00:45:27.260,00:45:30.350
"So the constant
factors get subsumed",00:45:30.350,00:45:35.430
beyond certain values of n.,00:45:35.430,00:45:37.160
"So that's why asymptotic
complexity is important.",00:45:37.160,00:45:39.835
"You do have a
factor of 20, here,",00:45:39.835,00:45:41.210
"but that doesn't really
help you in terms",00:45:41.210,00:45:43.270
"of keeping an n square
algorithm competitive.",00:45:43.270,00:45:47.440
"It stays competitive
for a little bit longer,",00:45:47.440,00:45:49.400
but then falls behind.,00:45:49.400,00:45:50.510
"That's what I wanted
to cover for sorting.",00:45:54.520,00:45:57.387
"So hopefully, you
have a sense of what",00:45:57.387,00:45:58.970
"happens with these two
sorting algorithms.",00:45:58.970,00:46:02.040
"We'll look at a very different
sorting algorithm next time,",00:46:02.040,00:46:05.200
"using heaps, which is a
different data structure.",00:46:05.200,00:46:08.460
"The last thing I want to do in
the couple minutes I have left",00:46:08.460,00:46:11.330
"is give you a little more
intuition as to recurrence",00:46:11.330,00:46:14.810
"solving based on this diagram
that I wrote up there.",00:46:14.810,00:46:18.680
"And so we're going to use
exactly this structure.",00:46:18.680,00:46:21.460
"And we're going to look at a
couple of different recurrences",00:46:21.460,00:46:24.250
"that I won't really
motivate in terms",00:46:24.250,00:46:26.360
"of having a specific
algorithm, but I'll just",00:46:26.360,00:46:29.420
write out the recurrence.,00:46:29.420,00:46:31.150
"And we'll look at the
recursion tree for that.",00:46:31.150,00:46:36.340
"And I'll try and tease out of
you the complexity associated",00:46:36.340,00:46:41.900
"with these recurrences of
the overall complexity.",00:46:41.900,00:46:45.635
"So let's take a look at T
of n equals 2 T of n over 2",00:46:49.480,00:46:58.000
plus c n squared.,00:46:58.000,00:47:00.310
"Let me just call that c--
no need for the brackets.",00:47:02.820,00:47:08.360
So constant c times n squared.,00:47:08.360,00:47:10.970
"So if you had a
crummy merge routine,",00:47:10.970,00:47:13.200
"and it was taking n square,
and you coded it up wrong.",00:47:13.200,00:47:18.020
"It's not a great motivation
for this recurrence,",00:47:18.020,00:47:20.050
"but it's a way this
recurrence could have come up.",00:47:20.050,00:47:23.980
"So what does this
recursive tree look like?",00:47:23.980,00:47:27.470
"Well it looks kind of
the same, obviously.",00:47:27.470,00:47:29.580
"You have c n square; you
have c n square divided by 4;",00:47:29.580,00:47:33.210
"c n square divided by
4; c n square divided",00:47:33.210,00:47:36.620
"by 16, four times.",00:47:36.620,00:47:40.620
"Looking a little bit
different from the other one.",00:47:40.620,00:47:44.460
"The levels and the leaves
are exactly the same.",00:47:44.460,00:47:47.560
"Eventually n is going
to go down to 1.",00:47:47.560,00:47:49.720
"So you will see c
all the way here.",00:47:49.720,00:47:53.280
"And you're going
to have n leaves.",00:47:53.280,00:47:54.735
"And you will have, as
before, 1 plus log n levels.",00:47:57.880,00:48:03.380
Everything is the same.,00:48:03.380,00:48:05.070
"And this is why I like this
recursive tree formulation so",00:48:05.070,00:48:07.590
"much because, now,
all I have to do",00:48:07.590,00:48:09.370
"is add up the work associated
with each of the levels",00:48:09.370,00:48:14.710
"to get the solution
to the recurrence.",00:48:14.710,00:48:17.100
"Now, take a look at
what happens, here.",00:48:17.100,00:48:18.770
"c n square; c n square divided
by 2; c n square divided by 4.",00:48:18.770,00:48:25.350
And this is n times c.,00:48:25.350,00:48:27.890
So what does that add up to?,00:48:30.890,00:48:34.316
AUDIENCE: [INAUDIBLE],00:48:34.316,00:48:35.839
"PROFESSOR: Yeah, exactly.",00:48:35.839,00:48:36.880
Exactly right.,00:48:36.880,00:48:37.920
"So if you look at what
happens, here, this dominates.",00:48:37.920,00:48:40.430
"All of the other things are
actually less than that.",00:48:44.340,00:48:47.520
"And you said bounded
by two c n square",00:48:47.520,00:48:49.250
"because this part is
bounded by c n square",00:48:49.250,00:48:51.420
"and I already have c n
square up at the top.",00:48:51.420,00:48:54.490
"So this particular algorithm
that corresponds to this crummy",00:48:54.490,00:48:58.100
"merge sort, or wherever
this recurrence came from,",00:48:58.100,00:49:02.300
is a theta n squared algorithm.,00:49:02.300,00:49:06.700
"And in this case,
all of the work done",00:49:06.700,00:49:10.520
"is at the root-- at the
top level of the recursion.",00:49:10.520,00:49:15.360
"Here, there was a
roughly equal amount",00:49:15.360,00:49:17.650
"of work done in each of
the different levels.",00:49:17.650,00:49:21.630
"Here, all of the work
was done at the root.",00:49:21.630,00:49:26.610
"And so to close
up shop, here, let",00:49:26.610,00:49:29.460
"me just give you real
quick a recurrence where",00:49:29.460,00:49:34.210
"all of the work is done at
the leaves, just for closure.",00:49:34.210,00:49:40.470
"So if I had, magically, a merge
routine that actually happened",00:49:40.470,00:49:45.770
"in constant time, either
through buggy analysis,",00:49:45.770,00:49:48.710
"or because of it
was buggy, then what",00:49:48.710,00:49:51.890
"does the tree look
like for that?",00:49:51.890,00:49:55.650
"And I can think of
this as being theta 1.",00:49:55.650,00:49:58.280
"Or I can think of this as
being just a constant c.",00:49:58.280,00:50:01.156
I'll stick with that.,00:50:01.156,00:50:02.030
"So I have c, c, c.",00:50:02.030,00:50:05.246
"Woah, I tried to move that up.",00:50:09.890,00:50:11.350
That doesn't work.,00:50:11.350,00:50:13.750
"So I have n leaves, as before.",00:50:13.750,00:50:15.545
"And so if I look at
what I have, here, I",00:50:18.314,00:50:19.980
have c at the top level.,00:50:19.980,00:50:21.840
"I have 2c, and so
on and so forth.",00:50:21.840,00:50:25.870
4c.,00:50:25.870,00:50:26.930
"And then I go all
the way down to nc.",00:50:26.930,00:50:30.940
"And so what happens
here is this dominates.",00:50:30.940,00:50:33.380
"And so, in this recurrence, the
whole thing runs in theta n.",00:50:36.010,00:50:41.600
"So the solution to
that is theta n.",00:50:41.600,00:50:46.300
"And what you have here
is all of the work",00:50:46.300,00:50:50.970
being done at the leaves.,00:50:50.970,00:50:54.450
"We're not going to really cover
this theorem that gives you",00:50:54.450,00:50:58.440
"a mechanical way of figuring
this out because we think",00:50:58.440,00:51:02.340
"the recursive tree is a
better way of looking at.",00:51:02.340,00:51:05.780
"But you can see that, depending
on what that function is,",00:51:05.780,00:51:08.920
"in terms of the work being
done in the merge routine,",00:51:08.920,00:51:12.130
"you'd have different
versions of recurrences.",00:51:12.130,00:51:14.490
"I'll stick around, and people
who answered questions, please",00:51:14.490,00:51:16.990
pick up you cushions.,00:51:16.990,00:51:18.270
See you next time.,00:51:18.270,00:51:20.240
